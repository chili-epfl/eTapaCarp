{"version":3,"file":"/packages/ThreeCSG.js","sources":["ThreeCSG/ThreeCSG.js"],"names":[],"mappings":";;;;;;;;AAAA,e;AACA,E;AACA,mB;AACA,iB;AACA,c;AACA,a;AACA,iB;AACA,G;AACA,oC;AACA,yC;AACA,qB;AACA,iC;AACA,a;AACA,mB;AACA,U;AACA,G;AACA,+C;AACA,qC;AACA,kD;AACA,oC;AACA,6B;AACA,2C;AACA,kC;AACA,qD;AACA,0B;AACA,qC;AACA,iB;AACA,Y;AACA,qD;AACA,K;AACA,G;AACA,0E;AACA,8B;AACA,kD;AACA,oC;AACA,K;AACA,yC;AACA,2C;AACA,2J;AACA,uC;AACA,sC;AACA,M;AACA,2C;AACA,2J;AACA,uC;AACA,sC;AACA,M;AACA,2C;AACA,2J;AACA,uC;AACA,sC;AACA,uC;AACA,2C;AACA,2J;AACA,uC;AACA,sC;AACA,M;AACA,2C;AACA,0J;AACA,uC;AACA,sC;AACA,M;AACA,2C;AACA,2J;AACA,uC;AACA,sC;AACA,M;AACA,2C;AACA,2J;AACA,uC;AACA,sC;AACA,a;AACA,8C;AACA,M;AACA,K;AACA,mC;AACA,8B;AACA,M;AACA,G;AACA,8C;AACA,K;AACA,yD;AACA,8B;AACA,iC;AACA,I;AACA,e;AACA,kB;AACA,kB;AACA,e;AACA,kB;AACA,e;AACA,+B;AACA,e;AACA,0B;AACA,2B;AACA,a;AACA,K;AACA,sD;AACA,8B;AACA,iC;AACA,I;AACA,kB;AACA,kB;AACA,e;AACA,kB;AACA,e;AACA,+B;AACA,0B;AACA,2B;AACA,a;AACA,K;AACA,0D;AACA,8B;AACA,iC;AACA,I;AACA,e;AACA,kB;AACA,e;AACA,kB;AACA,kB;AACA,+B;AACA,e;AACA,0B;AACA,2B;AACA,a;AACA,K;AACA,+C;AACA,a;AACA,4D;AACA,qC;AACA,wC;AACA,qC;AACA,oC;AACA,uB;AACA,8C;AACA,kB;AACA,gB;AACA,G;AACA,2C;AACA,2B;AACA,qD;AACA,K;AACA,oD;AACA,sB;AACA,M;AACA,mC;AACA,uE;AACA,iE;AACA,kC;AACA,M;AACA,gG;AACA,iF;AACA,c;AACA,wC;AACA,gH;AACA,O;AACA,M;AACA,qC;AACA,uE;AACA,iE;AACA,kC;AACA,gG;AACA,iF;AACA,c;AACA,wC;AACA,gH;AACA,O;AACA,M;AACA,mC;AACA,uE;AACA,iE;AACA,kC;AACA,gG;AACA,iF;AACA,c;AACA,wC;AACA,gH;AACA,O;AACA,M;AACA,6B;AACA,oB;AACA,oB;AACA,oB;AACA,gF;AACA,Q;AACA,M;AACA,kC;AACA,mD;AACA,M;AACA,K;AACA,K;AACA,oB;AACA,K;AACA,qD;AACA,qC;AACA,gD;AACA,I;AACA,yD;AACA,uC;AACA,+C;AACA,0B;AACA,kC;AACA,kB;AACA,gB;AACA,K;AACA,I;AACA,uD;AACA,2C;AACA,mB;AACA,K;AACA,I;AACA,6B;AACA,gC;AACA,gC;AACA,Y;AACA,sC;AACA,K;AACA,K;AACA,gE;AACA,6B;AACA,0B;AACA,0B;AACA,K;AACA,gD;AACA,4B;AACA,kB;AACA,I;AACA,0C;AACA,I;AACA,gB;AACA,K;AACA,kD;AACA,yB;AACA,oC;AACA,I;AACA,iF;AACA,uD;AACA,M;AACA,kC;AACA,I;AACA,mB;AACA,K;AACA,G;AACA,iD;AACA,yB;AACA,I;AACA,qC;AACA,iB;AACA,I;AACA,uD;AACA,uC;AACA,M;AACA,6B;AACA,I;AACA,gB;AACA,K;AACA,qE;AACA,wD;AACA,I;AACA,kC;AACA,iB;AACA,wC;AACA,kB;AACA,Y;AACA,qB;AACA,K;AACA,K;AACA,kE;AACA,kC;AACA,sB;AACA,sB;AACA,6C;AACA,I;AACA,2C;AACA,kC;AACA,oD;AACA,sC;AACA,qB;AACA,4C;AACA,qB;AACA,M;AACA,K;AACA,I;AACA,mD;AACA,kB;AACA,0D;AACA,iB;AACA,4D;AACA,qB;AACA,Y;AACA,qB;AACA,K;AACA,K;AACA,8G;AACA,sD;AACA,I;AACA,wC;AACA,K;AACA,gG;AACA,K;AACA,4C;AACA,K;AACA,2B;AACA,K;AACA,2C;AACA,K;AACA,0B;AACA,K;AACA,Y;AACA,K;AACA,uB;AACA,2B;AACA,W;AACA,a;AACA,a;AACA,K;AACA,qF;AACA,M;AACA,kC;AACA,+B;AACA,+B;AACA,qC;AACA,qC;AACA,M;AACA,qC;AACA,sC;AACA,qC;AACA,6F;AACA,mC;AACA,mB;AACA,mB;AACA,O;AACA,M;AACA,K;AACA,K;AACA,wF;AACA,uF;AACA,K;AACA,K;AACA,G;AACA,sD;AACA,e;AACA,e;AACA,e;AACA,8C;AACA,sC;AACA,K;AACA,iD;AACA,+F;AACA,K;AACA,uD;AACA,uB;AACA,uB;AACA,uB;AACA,gB;AACA,K;AACA,4D;AACA,uB;AACA,uB;AACA,uB;AACA,gB;AACA,K;AACA,kE;AACA,qB;AACA,qB;AACA,qB;AACA,gB;AACA,K;AACA,yD;AACA,mB;AACA,gB;AACA,gB;AACA,E;AACA,yC;AACA,yC;AACA,yC;AACA,I;AACA,gB;AACA,K;AACA,qD;AACA,kF;AACA,I;AACA,qB;AACA,qB;AACA,qB;AACA,I;AACA,gB;AACA,K;AACA,uD;AACA,qE;AACA,K;AACA,sD;AACA,a;AACA,mD;AACA,M;AACA,I;AACA,oB;AACA,4D;AACA,M;AACA,I;AACA,gB;AACA,oD;AACA,M;AACA,I;AACA,gB;AACA,K;AACA,iE;AACA,yC;AACA,K;AACA,4D;AACA,E;AACA,yC;AACA,E;AACA,2C;AACA,E;AACA,uB;AACA,E;AACA,qD;AACA,qD;AACA,qD;AACA,E;AACA,gB;AACA,E;AACA,I;AACA,G;AACA,G;AACA,yC;AACA,yB;AACA,gB;AACA,e;AACA,E;AACA,uB;AACA,uC;AACA,I;AACA,wE;AACA,E;AACA,uC;AACA,I;AACA,4E;AACA,yF;AACA,Q;AACA,I;AACA,6B;AACA,6C;AACA,K;AACA,I;AACA,4B;AACA,2C;AACA,K;AACA,K;AACA,kD;AACA,a;AACA,6C;AACA,8C;AACA,0E;AACA,oB;AACA,O;AACA,M;AACA,K;AACA,gB;AACA,K;AACA,yD;AACA,yB;AACA,gB;AACA,e;AACA,I;AACA,0B;AACA,wC;AACA,K;AACA,E;AACA,4E;AACA,yF;AACA,Q;AACA,I;AACA,6B;AACA,yD;AACA,+B;AACA,K;AACA,I;AACA,4B;AACA,uD;AACA,6B;AACA,K;AACA,K;AACA,qD;AACA,yC;AACA,6E;AACA,2E;AACA,oB;AACA,K;AACA,+C;AACA,mC;AACA,I;AACA,wC;AACA,yF;AACA,kD;AACA,+C;AACA,I;AACA,gB;AACA,K;AACA,gD;AACA,+B;AACA,I;AACA,iF;AACA,6B;AACA,K;AACA,I;AACA,wB;AACA,0C;AACA,wC;AACA,I;AACA,sB;AACA,2B;AACA,qB;AACA,I;AACA,gB;AACA,K;AACA,gE;AACA,yB;AACA,iB;AACA,E;AACA,iD;AACA,I;AACA,0B;AACA,I;AACA,4E;AACA,wE;AACA,K;AACA,E;AACA,+D;AACA,2D;AACA,mB;AACA,E;AACA,gC;AACA,K;AACA,G;AACA,sD;AACA,uD;AACA,gD;AACA,8C;AACA,K;AACA,G;AACA,G;;;AAGA,a;AACA,e;AACA,a;AACA,U;AACA,S;AACA,a;;AAEA,+B;AACA,yC;AACA,qB;AACA,wC;AACA,oB;AACA,0B;AACA,iB;;AAEA,6C;AACA,wC;AACA,gD;AACA,uC;AACA,gC;AACA,8C;AACA,qC;AACA,mD;AACA,6B;AACA,wC;AACA,oB;AACA,Y;AACA,wD;AACA,K;;AAEA,wE;AACA,iC;AACA,qD;AACA,uC;;AAEA,0C;AACA,iD;AACA,6J;AACA,6C;AACA,0C;;AAEA,iD;AACA,6J;AACA,6C;AACA,0C;;AAEA,iD;AACA,6J;AACA,6C;AACA,0C;AACA,wC;AACA,iD;AACA,6J;AACA,6C;AACA,0C;;AAEA,iD;AACA,6J;AACA,6C;AACA,0C;;AAEA,iD;AACA,6J;AACA,6C;AACA,0C;;AAEA,iD;AACA,6J;AACA,6C;AACA,0C;AACA,gB;AACA,oD;AACA,S;;AAEA,sC;AACA,+B;AACA,K;AACA,K;;AAEA,4C;AACA,E;AACA,oD;AACA,8B;AACA,wC;;AAEA,e;AACA,gB;AACA,gB;AACA,e;AACA,gB;AACA,e;AACA,6B;AACA,e;AACA,wB;AACA,2B;AACA,a;AACA,E;AACA,iD;AACA,8B;AACA,wC;;AAEA,gB;AACA,gB;AACA,e;AACA,gB;AACA,e;AACA,6B;AACA,wB;AACA,2B;AACA,a;AACA,E;AACA,qD;AACA,8B;AACA,wC;;AAEA,e;AACA,gB;AACA,e;AACA,gB;AACA,gB;AACA,6B;AACA,e;AACA,wB;AACA,2B;AACA,a;AACA,E;AACA,4C;AACA,a;AACA,iE;AACA,4C;AACA,+C;AACA,4C;AACA,2C;AACA,8B;AACA,qD;AACA,yB;AACA,uB;;AAEA,yC;AACA,8B;AACA,wD;;AAEA,qD;AACA,4B;;AAEA,yC;AACA,yE;AACA,qE;AACA,wC;;AAEA,oG;AACA,0F;AACA,oB;AACA,+C;AACA,yH;AACA,a;;AAEA,6C;AACA,yE;AACA,qE;AACA,wC;AACA,oG;AACA,0F;AACA,oB;AACA,+C;AACA,yH;AACA,a;;AAEA,yC;AACA,yE;AACA,qE;AACA,wC;AACA,oG;AACA,0F;AACA,oB;AACA,+C;AACA,yH;AACA,a;;AAEA,mC;AACA,iC;AACA,iC;AACA,iC;AACA,2F;AACA,sB;;AAEA,sC;AACA,uD;AACA,S;;AAEA,K;AACA,oB;AACA,E;AACA,gD;AACA,qC;AACA,sD;AACA,kC;AACA,uD;AACA,4D;;AAEA,gB;AACA,E;;;AAGA,kD;AACA,uC;AACA,sB;AACA,K;;AAEA,6B;AACA,8B;AACA,mC;AACA,Y;AACA,yC;AACA,K;AACA,E;AACA,6D;AACA,6B;AACA,iC;AACA,iC;;AAEA,8C;AACA,iC;AACA,0B;;AAEA,wC;;AAEA,gB;AACA,E;AACA,+C;AACA,yB;AACA,2C;;AAEA,+E;AACA,wD;AACA,K;AACA,K;AACA,kC;;AAEA,mB;AACA,E;;AAEA,8C;AACA,yB;;AAEA,mC;AACA,iB;;AAEA,qD;AACA,wC;AACA,K;AACA,K;AACA,6B;;AAEA,gB;AACA,E;AACA,8D;AACA,sD;;AAEA,gC;AACA,oB;AACA,sC;AACA,qB;AACA,Y;AACA,wB;AACA,K;AACA,E;AACA,6D;AACA,kC;AACA,6B;AACA,6B;AACA,oD;;AAEA,yC;AACA,qC;AACA,qD;AACA,uC;AACA,2B;AACA,6C;AACA,2B;AACA,S;AACA,K;;AAEA,iD;AACA,qB;AACA,wD;AACA,oB;AACA,0D;AACA,wB;AACA,Y;AACA,wB;AACA,K;AACA,E;AACA,yG;AACA,oD;;AAEA,sC;;AAEA,6F;;AAEA,0C;;AAEA,4B;;AAEA,yC;;AAEA,2B;;AAEA,Y;;AAEA,0B;AACA,qC;AACA,qB;AACA,uB;AACA,uB;;AAEA,sF;;AAEA,wC;AACA,qC;AACA,qC;AACA,yC;AACA,yC;;AAEA,2B;AACA,2B;AACA,4B;AACA,2B;AACA,yC;AACA,8F;AACA,0C;AACA,0B;AACA,0B;AACA,a;AACA,S;;;AAGA,0B;AACA,sE;AACA,0B;AACA,qE;AACA,K;AACA,E;;AAEA,iD;AACA,e;AACA,e;AACA,e;AACA,8C;AACA,sC;AACA,E;AACA,8C;AACA,6F;AACA,E;AACA,kD;AACA,uB;AACA,uB;AACA,uB;AACA,gB;AACA,E;AACA,uD;AACA,uB;AACA,uB;AACA,uB;AACA,gB;AACA,E;AACA,6D;AACA,qB;AACA,qB;AACA,qB;AACA,gB;AACA,E;AACA,oD;AACA,mB;AACA,uB;AACA,uB;;AAEA,yC;AACA,yC;AACA,yC;;AAEA,gB;AACA,E;AACA,kD;AACA,gF;;AAEA,qB;AACA,qB;AACA,qB;;AAEA,gB;AACA,E;AACA,kD;AACA,qE;AACA,E;AACA,iD;AACA,a;AACA,sD;AACA,c;;AAEA,oB;AACA,+D;AACA,c;;AAEA,gB;AACA,uD;AACA,c;;AAEA,gB;AACA,E;AACA,4D;AACA,uC;AACA,E;AACA,sD;;AAEA,yC;;AAEA,2C;;AAEA,uB;;AAEA,oD;AACA,oD;AACA,qD;;AAEA,gB;;AAEA,C;;;AAGA,oC;AACA,yB;AACA,uB;AACA,sB;;AAEA,uB;AACA,uC;;AAEA,8D;AACA,e;;AAEA,uC;;AAEA,0E;AACA,0F;AACA,K;;AAEA,2B;AACA,8C;AACA,K;;AAEA,0B;AACA,4C;AACA,K;AACA,E;AACA,6C;AACA,a;AACA,2C;AACA,+C;AACA,4E;AACA,6B;AACA,a;AACA,S;AACA,K;AACA,gB;AACA,E;AACA,oD;AACA,yB;AACA,uB;AACA,sB;;AAEA,wB;AACA,2C;AACA,K;;AAEA,0E;AACA,0F;AACA,K;;AAEA,2B;AACA,wB;AACA,6C;AACA,gC;AACA,K;;AAEA,0B;AACA,uB;AACA,4C;AACA,8B;AACA,K;AACA,E;AACA,kD;AACA,yC;AACA,mB;AACA,6D;AACA,kB;AACA,4D;AACA,oB;AACA,E;AACA,4C;AACA,mC;;AAEA,wC;AACA,yD;AACA,+B;AACA,O;AACA,kD;AACA,+C;;AAEA,gB;AACA,E;AACA,6C;AACA,+B;;AAEA,+E;AACA,gC;AACA,K;;AAEA,wB;AACA,mB;AACA,4B;AACA,kB;AACA,2B;;AAEA,sB;AACA,2B;AACA,qB;;AAEA,gB;AACA,E;AACA,2D;AACA,yB;AACA,wB;;AAEA,sB;AACA,gC;;AAEA,0B;;AAEA,0E;AACA,yE;AACA,K;;AAEA,mB;AACA,+C;AACA,kB;AACA,4C;AACA,Q;AACA,kB;;AAEA,8B;AACA,E;;AAEA,iD;AACA,qD;AACA,mB;AACA,gC;AACA,kB;AACA,+B;AACA,E","sourcesContent":["//'use strict';\n//\n//\t\tEPSILON = 1e-5,\n//\t\tCOPLANAR = 0,\n//\t\tFRONT = 1,\n//\t\tBACK = 2,\n//\t\tSPANNING = 3;\n//\t\n//\tThreeBSP = function( geometry ) {\n//\t\t// Convert THREE.Geometry to ThreeBSP\n//\t\tvar i, _length_i,\n//\t\t\tface, vertex, faceVertexUvs,\n//\t\t\tpolygon,\n//\t\t\tpolygons = [],\n//\t\t\ttree;\n//\t\n//\t\tif ( geometry instanceof THREE.Geometry ) {\n//\t\t\tthis.matrix = new THREE.Matrix4;\n//\t\t} else if ( geometry instanceof THREE.Mesh ) {\n//\t\t\t// #todo: add hierarchy support\n//\t\t\tgeometry.updateMatrix();\n//\t\t\tthis.matrix = geometry.matrix.clone();\n//\t\t\tgeometry = geometry.geometry;\n//\t\t} else if ( geometry instanceof ThreeBSP.Node ) {\n//\t\t\tthis.tree = geometry;\n//\t\t\tthis.matrix = new THREE.Matrix4;\n//\t\t\treturn this;\n//\t\t} else {\n//\t\t\tthrow 'ThreeBSP: Given geometry is unsupported';\n//\t\t}\n//\t\n//\t\tfor ( i = 0, _length_i = geometry.faces.length; i < _length_i; i++ ) {\n//\t\t\tface = geometry.faces[i];\n//\t\t\tfaceVertexUvs = geometry.faceVertexUvs[0][i];\n//\t\t\tpolygon = new ThreeBSP.Polygon;\n//\t\t\t\n//\t\t\tif ( face instanceof THREE.Face3 ) {\n//\t\t\t\tvertex = geometry.vertices[ face.a ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z, face.vertexNormals[0]);//, new THREE.Vector2( faceVertexUvs[0].x, faceVertexUvs[0].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t\t\n//\t\t\t\tvertex = geometry.vertices[ face.b ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z, face.vertexNormals[1]);//, new THREE.Vector2( faceVertexUvs[1].x, faceVertexUvs[1].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t\t\n//\t\t\t\tvertex = geometry.vertices[ face.c ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z, face.vertexNormals[2]);//, new THREE.Vector2( faceVertexUvs[2].x, faceVertexUvs[2].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t} else if ( typeof THREE.Face4 ) {\n//\t\t\t\tvertex = geometry.vertices[ face.a ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z, face.vertexNormals[0]);//, new THREE.Vector2( faceVertexUvs[0].x, faceVertexUvs[0].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t\t\n//\t\t\t\tvertex = geometry.vertices[ face.b ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z,face.vertexNormals[1]);//, new THREE.Vector2( faceVertexUvs[1].x, faceVertexUvs[1].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t\t\n//\t\t\t\tvertex = geometry.vertices[ face.c ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z, face.vertexNormals[2]);//, new THREE.Vector2( faceVertexUvs[2].x, faceVertexUvs[2].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t\t\n//\t\t\t\tvertex = geometry.vertices[ face.d ];\n//\t\t\t\tvertex = new ThreeBSP.Vertex( vertex.x, vertex.y, vertex.z, face.vertexNormals[3]);//, new THREE.Vector2( faceVertexUvs[3].x, faceVertexUvs[3].y ) );\n//\t\t\t\tvertex.applyMatrix4(this.matrix);\n//\t\t\t\tpolygon.vertices.push( vertex );\n//\t\t\t} else {\n//\t\t\t\tthrow 'Invalid face type at index ' + i;\n//\t\t\t}\n//\t\t\t\n//\t\t\tpolygon.calculateProperties();\n//\t\t\tpolygons.push( polygon );\n//\t\t};\n//\t\n//\t\tthis.tree = new ThreeBSP.Node( polygons );\n//\t};\n//\tThreeBSP.prototype.subtract = function( other_tree ) {\n//\t\tvar a = this.tree.clone(),\n//\t\t\tb = other_tree.tree.clone();\n//\t\t\n//\t\ta.invert();\n//\t\ta.clipTo( b );\n//\t\tb.clipTo( a );\n//\t\tb.invert();\n//\t\tb.clipTo( a );\n//\t\tb.invert();\n//\t\ta.build( b.allPolygons() );\n//\t\ta.invert();\n//\t\ta = new ThreeBSP( a );\n//\t\ta.matrix = this.matrix;\n//\t\treturn a;\n//\t};\n//\tThreeBSP.prototype.union = function( other_tree ) {\n//\t\tvar a = this.tree.clone(),\n//\t\t\tb = other_tree.tree.clone();\n//\t\t\n//\t\ta.clipTo( b );\n//\t\tb.clipTo( a );\n//\t\tb.invert();\n//\t\tb.clipTo( a );\n//\t\tb.invert();\n//\t\ta.build( b.allPolygons() );\n//\t\ta = new ThreeBSP( a );\n//\t\ta.matrix = this.matrix;\n//\t\treturn a;\n//\t};\n//\tThreeBSP.prototype.intersect = function( other_tree ) {\n//\t\tvar a = this.tree.clone(),\n//\t\t\tb = other_tree.tree.clone();\n//\t\t\n//\t\ta.invert();\n//\t\tb.clipTo( a );\n//\t\tb.invert();\n//\t\ta.clipTo( b );\n//\t\tb.clipTo( a );\n//\t\ta.build( b.allPolygons() );\n//\t\ta.invert();\n//\t\ta = new ThreeBSP( a );\n//\t\ta.matrix = this.matrix;\n//\t\treturn a;\n//\t};\n//\tThreeBSP.prototype.toGeometry = function() {\n//\t\tvar i, j,\n//\t\t\tmatrix = new THREE.Matrix4().getInverse( this.matrix ),\n//\t\t\tgeometry = new THREE.Geometry(),\n//\t\t\tpolygons = this.tree.allPolygons(),\n//\t\t\tpolygon_count = polygons.length,\n//\t\t\tpolygon, polygon_vertice_count,\n//\t\t\tvertice_dict = {},\n//\t\t\tvertex_idx_a, vertex_idx_b, vertex_idx_c,\n//\t\t\tvertex, face,\n//\t\t\tverticeUvs;\n//\t\n//\t\tfor ( i = 0; i < polygon_count; i++ ) {\n//\t\t\tpolygon = polygons[i];\n//\t\t\tpolygon_vertice_count = polygon.vertices.length;\n//\t\t\t\n//\t\t\tfor ( j = 2; j < polygon_vertice_count; j++ ) {\n//\t\t\t\tverticeUvs = [];\n//\t\t\t\t\n//\t\t\t\tvertex = polygon.vertices[0];\n//\t\t\t\tverticeUvs.push( new THREE.Vector2( vertex.uv.x, vertex.uv.y ) );\n//\t\t\t\tvertex = new THREE.Vector3( vertex.x, vertex.y, vertex.z );\n//\t\t\t\tvertex.applyMatrix4(matrix);\n//\t\t\t\t\n//\t\t\t\tif ( typeof vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] !== 'undefined' ) {\n//\t\t\t\t\tvertex_idx_a = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ];\n//\t\t\t\t} else {\n//\t\t\t\t\tgeometry.vertices.push( vertex );\n//\t\t\t\t\tvertex_idx_a = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] = geometry.vertices.length - 1;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tvertex = polygon.vertices[j-1];\n//\t\t\t\tverticeUvs.push( new THREE.Vector2( vertex.uv.x, vertex.uv.y ) );\n//\t\t\t\tvertex = new THREE.Vector3( vertex.x, vertex.y, vertex.z );\n//\t\t\t\tvertex.applyMatrix4(matrix);\n//\t\t\t\tif ( typeof vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] !== 'undefined' ) {\n//\t\t\t\t\tvertex_idx_b = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ];\n//\t\t\t\t} else {\n//\t\t\t\t\tgeometry.vertices.push( vertex );\n//\t\t\t\t\tvertex_idx_b = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] = geometry.vertices.length - 1;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tvertex = polygon.vertices[j];\n//\t\t\t\tverticeUvs.push( new THREE.Vector2( vertex.uv.x, vertex.uv.y ) );\n//\t\t\t\tvertex = new THREE.Vector3( vertex.x, vertex.y, vertex.z );\n//\t\t\t\tvertex.applyMatrix4(matrix);\n//\t\t\t\tif ( typeof vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] !== 'undefined' ) {\n//\t\t\t\t\tvertex_idx_c = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ];\n//\t\t\t\t} else {\n//\t\t\t\t\tgeometry.vertices.push( vertex );\n//\t\t\t\t\tvertex_idx_c = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] = geometry.vertices.length - 1;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tface = new THREE.Face3(\n//\t\t\t\t\tvertex_idx_a,\n//\t\t\t\t\tvertex_idx_b,\n//\t\t\t\t\tvertex_idx_c,\n//\t\t\t\t\tnew THREE.Vector3( polygon.normal.x, polygon.normal.y, polygon.normal.z )\n//\t\t\t\t);\n//\t\t\t\t\n//\t\t\t\tgeometry.faces.push( face );\n//\t\t\t\tgeometry.faceVertexUvs[0].push( verticeUvs );\n//\t\t\t}\n//\t\t\t\n//\t\t}\n//\t\treturn geometry;\n//\t};\n//\tThreeBSP.prototype.toMesh = function( material ) {\n//\t\tvar geometry = this.toGeometry(),\n//\t\tmesh = new THREE.Mesh( geometry, material );\n//\t\t\n////\t\tmesh.position.getPositionFromMatrix( this.matrix );\n////\t\tvar euler=new THREE.Euler(0,0,0);\n////\t\teuler.setFromRotationMatrix(this.matrix);\n////\t\tmesh.rotation=euler;\n//\t\tmesh.applyMatrix(this.matrix);\n//                \n//\t\treturn mesh;\n//\t};\n//\t\t\n//\tThreeBSP.Polygon = function( vertices, normal, w ) {\n//\t\tif ( !( vertices instanceof Array ) ) {\n//\t\t\tvertices = [];\n//\t\t}\n//\t\t\n//\t\tthis.vertices = vertices;\n//\t\tif ( vertices.length > 0 ) {\n//\t\t\tthis.calculateProperties();\n//\t\t} else {\n//\t\t\tthis.normal = this.w = undefined;\n//\t\t}\n//\t};\n//\tThreeBSP.Polygon.prototype.calculateProperties = function() {\n//\t\tvar a = this.vertices[0],\n//\t\t\tb = this.vertices[1],\n//\t\t\tc = this.vertices[2];\n//\t\t\t\n//\t\tthis.normal = b.clone().subtract( a ).cross(\n//\t\t\tc.clone().subtract( a )\n//\t\t).normalize();\n//\t\t\n//\t\tthis.w = this.normal.clone().dot( a );\n//\t\t\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Polygon.prototype.clone = function() {\n//\t\tvar i, vertice_count,\n//\t\t\tpolygon = new ThreeBSP.Polygon;\n//\t\t\n//\t\tfor ( i = 0, vertice_count = this.vertices.length; i < vertice_count; i++ ) {\n//\t\t\tpolygon.vertices.push( this.vertices[i].clone() );\n//\t\t};\n//\t\tpolygon.calculateProperties();\n//\t\t\n//\t\treturn polygon;\n//\t};\n//\t\n//\tThreeBSP.Polygon.prototype.flip = function() {\n//\t\tvar i, vertices = [];\n//\t\t\n//\t\tthis.normal.multiplyScalar( -1 );\n//\t\tthis.w *= -1;\n//\t\t\n//\t\tfor ( i = this.vertices.length - 1; i >= 0; i-- ) {\n//\t\t\tvertices.push( this.vertices[i] );\n//\t\t};\n//\t\tthis.vertices = vertices;\n//\t\t\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Polygon.prototype.classifyVertex = function( vertex ) {  \n//\t\tvar side_value = this.normal.dot( vertex ) - this.w;\n//\t\t\n//\t\tif ( side_value < -EPSILON ) {\n//\t\t\treturn BACK;\n//\t\t} else if ( side_value > EPSILON ) {\n//\t\t\treturn FRONT;\n//\t\t} else {\n//\t\t\treturn COPLANAR;\n//\t\t}\n//\t};\n//\tThreeBSP.Polygon.prototype.classifySide = function( polygon ) {\n//\t\tvar i, vertex, classification,\n//\t\t\tnum_positive = 0,\n//\t\t\tnum_negative = 0,\n//\t\t\tvertice_count = polygon.vertices.length;\n//\t\t\n//\t\tfor ( i = 0; i < vertice_count; i++ ) {\n//\t\t\tvertex = polygon.vertices[i];\n//\t\t\tclassification = this.classifyVertex( vertex );\n//\t\t\tif ( classification === FRONT ) {\n//\t\t\t\tnum_positive++;\n//\t\t\t} else if ( classification === BACK ) {\n//\t\t\t\tnum_negative++;\n//\t\t\t}\n//\t\t}\n//\t\t\n//\t\tif ( num_positive > 0 && num_negative === 0 ) {\n//\t\t\treturn FRONT;\n//\t\t} else if ( num_positive === 0 && num_negative > 0 ) {\n//\t\t\treturn BACK;\n//\t\t} else if ( num_positive === 0 && num_negative === 0 ) {\n//\t\t\treturn COPLANAR;\n//\t\t} else {\n//\t\t\treturn SPANNING;\n//\t\t}\n//\t};\n//\tThreeBSP.Polygon.prototype.splitPolygon = function( polygon, coplanar_front, coplanar_back, front, back ) {\n//\t\tvar classification = this.classifySide( polygon );\n//\t\t\n//\t\tif ( classification === COPLANAR ) {\n//\t\t\t\n//\t\t\t( this.normal.dot( polygon.normal ) > 0 ? coplanar_front : coplanar_back ).push( polygon );\n//\t\t\t\n//\t\t} else if ( classification === FRONT ) {\n//\t\t\t\n//\t\t\tfront.push( polygon );\n//\t\t\t\n//\t\t} else if ( classification === BACK ) {\n//\t\t\t\n//\t\t\tback.push( polygon );\n//\t\t\t\n//\t\t} else {\n//\t\t\t\n//\t\t\tvar vertice_count,\n//\t\t\t\ti, j, ti, tj, vi, vj,\n//\t\t\t\tt, v,\n//\t\t\t\tf = [],\n//\t\t\t\tb = [];\n//\t\t\t\n//\t\t\tfor ( i = 0, vertice_count = polygon.vertices.length; i < vertice_count; i++ ) {\n//\t\t\t\t\n//\t\t\t\tj = (i + 1) % vertice_count;\n//\t\t\t\tvi = polygon.vertices[i];\n//\t\t\t\tvj = polygon.vertices[j];\n//\t\t\t\tti = this.classifyVertex( vi );\n//\t\t\t\ttj = this.classifyVertex( vj );\n//\t\t\t\t\n//\t\t\t\tif ( ti != BACK ) f.push( vi );\n//\t\t\t\tif ( ti != FRONT ) b.push( vi );\n//\t\t\t\tif ( (ti | tj) === SPANNING ) {\n//\t\t\t\t\tt = ( this.w - this.normal.dot( vi ) ) / this.normal.dot( vj.clone().subtract( vi ) );\n//\t\t\t\t\tv = vi.interpolate( vj, t );\n//\t\t\t\t\tf.push( v );\n//\t\t\t\t\tb.push( v );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t\n//\t\t\t\n//\t\t\tif ( f.length >= 3 ) front.push( new ThreeBSP.Polygon( f ).calculateProperties() );\n//\t\t\tif ( b.length >= 3 ) back.push( new ThreeBSP.Polygon( b ).calculateProperties() );\n//\t\t}\n//\t};\n//\t\n//\tThreeBSP.Vertex = function( x, y, z, normal, uv ) {\n//\t\tthis.x = x;\n//\t\tthis.y = y;\n//\t\tthis.z = z;\n//\t\tthis.normal = normal || new THREE.Vector3;\n//\t\tthis.uv = uv || new THREE.Vector2;\n//\t};\n//\tThreeBSP.Vertex.prototype.clone = function() {\n//\t\treturn new ThreeBSP.Vertex( this.x, this.y, this.z, this.normal.clone(), this.uv.clone() );\n//\t};\n//\tThreeBSP.Vertex.prototype.add = function( vertex ) {\n//\t\tthis.x += vertex.x;\n//\t\tthis.y += vertex.y;\n//\t\tthis.z += vertex.z;\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Vertex.prototype.subtract = function( vertex ) {\n//\t\tthis.x -= vertex.x;\n//\t\tthis.y -= vertex.y;\n//\t\tthis.z -= vertex.z;\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Vertex.prototype.multiplyScalar = function( scalar ) {\n//\t\tthis.x *= scalar;\n//\t\tthis.y *= scalar;\n//\t\tthis.z *= scalar;\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Vertex.prototype.cross = function( vertex ) {\n//\t\tvar x = this.x,\n//\t\t\ty = this.y,\n//\t\t\tz = this.z;\n//\n//\t\tthis.x = y * vertex.z - z * vertex.y;\n//\t\tthis.y = z * vertex.x - x * vertex.z;\n//\t\tthis.z = x * vertex.y - y * vertex.x;\n//\t\t\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Vertex.prototype.normalize = function() {\n//\t\tvar length = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n//\t\t\n//\t\tthis.x /= length;\n//\t\tthis.y /= length;\n//\t\tthis.z /= length;\n//\t\t\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Vertex.prototype.dot = function( vertex ) {\n//\t\treturn this.x * vertex.x + this.y * vertex.y + this.z * vertex.z;\n//\t};\n//\tThreeBSP.Vertex.prototype.lerp = function( a, t ) {\n//\t\tthis.add(\n//\t\t\ta.clone().subtract( this ).multiplyScalar( t )\n//\t\t);\n//\t\t\n//\t\tthis.normal.add(\n//\t\t\ta.normal.clone().sub( this.normal ).multiplyScalar( t )\n//\t\t);\n//\t\t\n//\t\tthis.uv.add(\n//\t\t\ta.uv.clone().sub( this.uv ).multiplyScalar( t )\n//\t\t);\n//\t\t\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Vertex.prototype.interpolate = function( other, t ) {\n//\t\treturn this.clone().lerp( other, t );\n//\t};\n//\tThreeBSP.Vertex.prototype.applyMatrix4 = function ( m ) {\n//\n//\t\t// input: THREE.Matrix4 affine matrix\n//\n//\t\tvar x = this.x, y = this.y, z = this.z;\n//\n//\t\tvar e = m.elements;\n//\n//\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\n//\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\n//\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n//\n//\t\treturn this;\n//\n//\t}\n//\t\n//\t\n//\tThreeBSP.Node = function( polygons ) {\n//\t\tvar i, polygon_count,\n//\t\t\tfront = [],\n//\t\t\tback = [];\n//\n//\t\tthis.polygons = [];\n//\t\tthis.front = this.back = undefined;\n//\t\t\n//\t\tif ( !(polygons instanceof Array) || polygons.length === 0 ) return;\n//\n//\t\tthis.divider = polygons[0].clone();\n//\t\t\n//\t\tfor ( i = 0, polygon_count = polygons.length; i < polygon_count; i++ ) {\n//\t\t\tthis.divider.splitPolygon( polygons[i], this.polygons, this.polygons, front, back );\n//\t\t}   \n//\t\t\n//\t\tif ( front.length > 0 ) {\n//\t\t\tthis.front = new ThreeBSP.Node( front );\n//\t\t}\n//\t\t\n//\t\tif ( back.length > 0 ) {\n//\t\t\tthis.back = new ThreeBSP.Node( back );\n//\t\t}\n//\t};\n//\tThreeBSP.Node.isConvex = function( polygons ) {\n//\t\tvar i, j;\n//\t\tfor ( i = 0; i < polygons.length; i++ ) {\n//\t\t\tfor ( j = 0; j < polygons.length; j++ ) {\n//\t\t\t\tif ( i !== j && polygons[i].classifySide( polygons[j] ) !== BACK ) {\n//\t\t\t\t\treturn false;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\treturn true;\n//\t};\n//\tThreeBSP.Node.prototype.build = function( polygons ) {\n//\t\tvar i, polygon_count,\n//\t\t\tfront = [],\n//\t\t\tback = [];\n//\t\t\n//\t\tif ( !this.divider ) {\n//\t\t\tthis.divider = polygons[0].clone();\n//\t\t}\n//\n//\t\tfor ( i = 0, polygon_count = polygons.length; i < polygon_count; i++ ) {\n//\t\t\tthis.divider.splitPolygon( polygons[i], this.polygons, this.polygons, front, back );\n//\t\t}   \n//\t\t\n//\t\tif ( front.length > 0 ) {\n//\t\t\tif ( !this.front ) this.front = new ThreeBSP.Node();\n//\t\t\tthis.front.build( front );\n//\t\t}\n//\t\t\n//\t\tif ( back.length > 0 ) {\n//\t\t\tif ( !this.back ) this.back = new ThreeBSP.Node();\n//\t\t\tthis.back.build( back );\n//\t\t}\n//\t};\n//\tThreeBSP.Node.prototype.allPolygons = function() {\n//\t\tvar polygons = this.polygons.slice();\n//\t\tif ( this.front ) polygons = polygons.concat( this.front.allPolygons() );\n//\t\tif ( this.back ) polygons = polygons.concat( this.back.allPolygons() );\n//\t\treturn polygons;\n//\t};\n//\tThreeBSP.Node.prototype.clone = function() {\n//\t\tvar node = new ThreeBSP.Node();\n//\t\t\n//\t\tnode.divider = this.divider.clone();\n//\t\tnode.polygons = this.polygons.map( function( polygon ) { return polygon.clone(); } );\n//\t\tnode.front = this.front && this.front.clone();\n//\t\tnode.back = this.back && this.back.clone();\n//\t\t\n//\t\treturn node;\n//\t};\n//\tThreeBSP.Node.prototype.invert = function() {\n//\t\tvar i, polygon_count, temp;\n//\t\t\n//\t\tfor ( i = 0, polygon_count = this.polygons.length; i < polygon_count; i++ ) {\n//\t\t\tthis.polygons[i].flip();\n//\t\t}\n//\t\t\n//\t\tthis.divider.flip();\n//\t\tif ( this.front ) this.front.invert();\n//\t\tif ( this.back ) this.back.invert();\n//\t\t\n//\t\ttemp = this.front;\n//\t\tthis.front = this.back;\n//\t\tthis.back = temp;\n//\t\t\n//\t\treturn this;\n//\t};\n//\tThreeBSP.Node.prototype.clipPolygons = function( polygons ) {\n//\t\tvar i, polygon_count,\n//\t\t\tfront, back;\n//\n//\t\tif ( !this.divider ) return polygons.slice();\n//\t\t\n//\t\tfront = [], back = [];\n//\t\t\n//\t\tfor ( i = 0, polygon_count = polygons.length; i < polygon_count; i++ ) {\n//\t\t\tthis.divider.splitPolygon( polygons[i], front, back, front, back );\n//\t\t}\n//\n//\t\tif ( this.front ) front = this.front.clipPolygons( front );\n//\t\tif ( this.back ) back = this.back.clipPolygons( back );\n//\t\telse back = [];\n//\n//\t\treturn front.concat( back );\n//\t};\n//\t\n//\tThreeBSP.Node.prototype.clipTo = function( node ) {\n//\t\tthis.polygons = node.clipPolygons( this.polygons );\n//\t\tif ( this.front ) this.front.clipTo( node );\n//\t\tif ( this.back ) this.back.clipTo( node );\n//\t};\n//\t\n//\t\n\n\n'use strict';\nEPSILON = 1e-5,\nCOPLANAR = 0,\nFRONT = 1,\nBACK = 2,\nSPANNING = 3;\n\nThreeBSP = function(geometry) {\n    // Convert THREE.Geometry to ThreeBSP\n    var i, _length_i,\n            face, vertex, faceVertexUvs,\n            polygon,\n            polygons = [],\n            tree;\n\n    if (geometry instanceof THREE.Geometry) {\n        this.matrix = new THREE.Matrix4;\n    } else if (geometry instanceof THREE.Mesh) {\n        // #todo: add hierarchy support\n        geometry.updateMatrix();\n        this.matrix = geometry.matrix.clone();\n        geometry = geometry.geometry;\n    } else if (geometry instanceof ThreeBSP.Node) {\n        this.tree = geometry;\n        this.matrix = new THREE.Matrix4;\n        return this;\n    } else {\n        throw 'ThreeBSP: Given geometry is unsupported';\n    }\n\n    for (i = 0, _length_i = geometry.faces.length; i < _length_i; i++) {\n        face = geometry.faces[i];\n        faceVertexUvs = geometry.faceVertexUvs[0][i];\n        polygon = new ThreeBSP.Polygon;\n\n        if (face instanceof THREE.Face3) {\n            vertex = geometry.vertices[ face.a ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0]);//, new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n\n            vertex = geometry.vertices[ face.b ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1]);//, new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n\n            vertex = geometry.vertices[ face.c ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2]);//, new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n        } else if (typeof THREE.Face4) {\n            vertex = geometry.vertices[ face.a ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0]);//, new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n\n            vertex = geometry.vertices[ face.b ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1]);//, new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n\n            vertex = geometry.vertices[ face.c ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2]);//, new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n\n            vertex = geometry.vertices[ face.d ];\n            vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[3]);//, new THREE.Vector2(faceVertexUvs[3].x, faceVertexUvs[3].y));\n            vertex.applyMatrix4(this.matrix);\n            polygon.vertices.push(vertex);\n        } else {\n            throw 'Invalid face type at index ' + i;\n        }\n\n        polygon.calculateProperties();\n        polygons.push(polygon);\n    }\n    ;\n\n    this.tree = new ThreeBSP.Node(polygons);\n};\nThreeBSP.prototype.subtract = function(other_tree) {\n    var a = this.tree.clone(),\n            b = other_tree.tree.clone();\n\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    a = new ThreeBSP(a);\n    a.matrix = this.matrix;\n    return a;\n};\nThreeBSP.prototype.union = function(other_tree) {\n    var a = this.tree.clone(),\n            b = other_tree.tree.clone();\n\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a = new ThreeBSP(a);\n    a.matrix = this.matrix;\n    return a;\n};\nThreeBSP.prototype.intersect = function(other_tree) {\n    var a = this.tree.clone(),\n            b = other_tree.tree.clone();\n\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    a = new ThreeBSP(a);\n    a.matrix = this.matrix;\n    return a;\n};\nThreeBSP.prototype.toGeometry = function() {\n    var i, j,\n            matrix = new THREE.Matrix4().getInverse(this.matrix),\n            geometry = new THREE.Geometry(),\n            polygons = this.tree.allPolygons(),\n            polygon_count = polygons.length,\n            polygon, polygon_vertice_count,\n            vertice_dict = {},\n            vertex_idx_a, vertex_idx_b, vertex_idx_c,\n            vertex, face,\n            verticeUvs;\n\n    for (i = 0; i < polygon_count; i++) {\n        polygon = polygons[i];\n        polygon_vertice_count = polygon.vertices.length;\n\n        for (j = 2; j < polygon_vertice_count; j++) {\n            verticeUvs = [];\n\n            vertex = polygon.vertices[0];\n            verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n            vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n            vertex.applyMatrix4(matrix);\n\n            if (typeof vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] !== 'undefined') {\n                vertex_idx_a = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ];\n            } else {\n                geometry.vertices.push(vertex);\n                vertex_idx_a = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] = geometry.vertices.length - 1;\n            }\n\n            vertex = polygon.vertices[j - 1];\n            verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n            vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n            vertex.applyMatrix4(matrix);\n            if (typeof vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] !== 'undefined') {\n                vertex_idx_b = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ];\n            } else {\n                geometry.vertices.push(vertex);\n                vertex_idx_b = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] = geometry.vertices.length - 1;\n            }\n\n            vertex = polygon.vertices[j];\n            verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n            vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n            vertex.applyMatrix4(matrix);\n            if (typeof vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] !== 'undefined') {\n                vertex_idx_c = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ];\n            } else {\n                geometry.vertices.push(vertex);\n                vertex_idx_c = vertice_dict[ vertex.x + ',' + vertex.y + ',' + vertex.z ] = geometry.vertices.length - 1;\n            }\n\n            face = new THREE.Face3(\n                    vertex_idx_a,\n                    vertex_idx_b,\n                    vertex_idx_c,\n                    new THREE.Vector3(polygon.normal.x, polygon.normal.y, polygon.normal.z)\n                    );\n\n            geometry.faces.push(face);\n            geometry.faceVertexUvs[0].push(verticeUvs);\n        }\n\n    }\n    return geometry;\n};\nThreeBSP.prototype.toMesh = function(material) {\n    var geometry = this.toGeometry(),\n            mesh = new THREE.Mesh(geometry, material);\n    mesh.applyMatrix(this.matrix);\n    //mesh.position.getPositionFromMatrix(this.matrix);\n    //mesh.rotation.setEulerFromRotationMatrix(this.matrix);\n\n    return mesh;\n};\n\n\nThreeBSP.Polygon = function(vertices, normal, w) {\n    if (!(vertices instanceof Array)) {\n        vertices = [];\n    }\n\n    this.vertices = vertices;\n    if (vertices.length > 0) {\n        this.calculateProperties();\n    } else {\n        this.normal = this.w = undefined;\n    }\n};\nThreeBSP.Polygon.prototype.calculateProperties = function() {\n    var a = this.vertices[0],\n            b = this.vertices[1],\n            c = this.vertices[2];\n\n    this.normal = b.clone().subtract(a).cross(\n            c.clone().subtract(a)\n            ).normalize();\n\n    this.w = this.normal.clone().dot(a);\n\n    return this;\n};\nThreeBSP.Polygon.prototype.clone = function() {\n    var i, vertice_count,\n            polygon = new ThreeBSP.Polygon;\n\n    for (i = 0, vertice_count = this.vertices.length; i < vertice_count; i++) {\n        polygon.vertices.push(this.vertices[i].clone());\n    }\n    ;\n    polygon.calculateProperties();\n\n    return polygon;\n};\n\nThreeBSP.Polygon.prototype.flip = function() {\n    var i, vertices = [];\n\n    this.normal.multiplyScalar(-1);\n    this.w *= -1;\n\n    for (i = this.vertices.length - 1; i >= 0; i--) {\n        vertices.push(this.vertices[i]);\n    }\n    ;\n    this.vertices = vertices;\n\n    return this;\n};\nThreeBSP.Polygon.prototype.classifyVertex = function(vertex) {\n    var side_value = this.normal.dot(vertex) - this.w;\n\n    if (side_value < -EPSILON) {\n        return BACK;\n    } else if (side_value > EPSILON) {\n        return FRONT;\n    } else {\n        return COPLANAR;\n    }\n};\nThreeBSP.Polygon.prototype.classifySide = function(polygon) {\n    var i, vertex, classification,\n            num_positive = 0,\n            num_negative = 0,\n            vertice_count = polygon.vertices.length;\n\n    for (i = 0; i < vertice_count; i++) {\n        vertex = polygon.vertices[i];\n        classification = this.classifyVertex(vertex);\n        if (classification === FRONT) {\n            num_positive++;\n        } else if (classification === BACK) {\n            num_negative++;\n        }\n    }\n\n    if (num_positive > 0 && num_negative === 0) {\n        return FRONT;\n    } else if (num_positive === 0 && num_negative > 0) {\n        return BACK;\n    } else if (num_positive === 0 && num_negative === 0) {\n        return COPLANAR;\n    } else {\n        return SPANNING;\n    }\n};\nThreeBSP.Polygon.prototype.splitPolygon = function(polygon, coplanar_front, coplanar_back, front, back) {\n    var classification = this.classifySide(polygon);\n\n    if (classification === COPLANAR) {\n\n        (this.normal.dot(polygon.normal) > 0 ? coplanar_front : coplanar_back).push(polygon);\n\n    } else if (classification === FRONT) {\n\n        front.push(polygon);\n\n    } else if (classification === BACK) {\n\n        back.push(polygon);\n\n    } else {\n\n        var vertice_count,\n                i, j, ti, tj, vi, vj,\n                t, v,\n                f = [],\n                b = [];\n\n        for (i = 0, vertice_count = polygon.vertices.length; i < vertice_count; i++) {\n\n            j = (i + 1) % vertice_count;\n            vi = polygon.vertices[i];\n            vj = polygon.vertices[j];\n            ti = this.classifyVertex(vi);\n            tj = this.classifyVertex(vj);\n\n            if (ti != BACK)\n                f.push(vi);\n            if (ti != FRONT)\n                b.push(vi);\n            if ((ti | tj) === SPANNING) {\n                t = (this.w - this.normal.dot(vi)) / this.normal.dot(vj.clone().subtract(vi));\n                v = vi.interpolate(vj, t);\n                f.push(v);\n                b.push(v);\n            }\n        }\n\n\n        if (f.length >= 3)\n            front.push(new ThreeBSP.Polygon(f).calculateProperties());\n        if (b.length >= 3)\n            back.push(new ThreeBSP.Polygon(b).calculateProperties());\n    }\n};\n\nThreeBSP.Vertex = function(x, y, z, normal, uv) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.normal = normal || new THREE.Vector3;\n    this.uv = uv || new THREE.Vector2;\n};\nThreeBSP.Vertex.prototype.clone = function() {\n    return new ThreeBSP.Vertex(this.x, this.y, this.z, this.normal.clone(), this.uv.clone());\n};\nThreeBSP.Vertex.prototype.add = function(vertex) {\n    this.x += vertex.x;\n    this.y += vertex.y;\n    this.z += vertex.z;\n    return this;\n};\nThreeBSP.Vertex.prototype.subtract = function(vertex) {\n    this.x -= vertex.x;\n    this.y -= vertex.y;\n    this.z -= vertex.z;\n    return this;\n};\nThreeBSP.Vertex.prototype.multiplyScalar = function(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n};\nThreeBSP.Vertex.prototype.cross = function(vertex) {\n    var x = this.x,\n            y = this.y,\n            z = this.z;\n\n    this.x = y * vertex.z - z * vertex.y;\n    this.y = z * vertex.x - x * vertex.z;\n    this.z = x * vertex.y - y * vertex.x;\n\n    return this;\n};\nThreeBSP.Vertex.prototype.normalize = function() {\n    var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\n    this.x /= length;\n    this.y /= length;\n    this.z /= length;\n\n    return this;\n};\nThreeBSP.Vertex.prototype.dot = function(vertex) {\n    return this.x * vertex.x + this.y * vertex.y + this.z * vertex.z;\n};\nThreeBSP.Vertex.prototype.lerp = function(a, t) {\n    this.add(\n            a.clone().subtract(this).multiplyScalar(t)\n            );\n\n    this.normal.add(\n            a.normal.clone().sub(this.normal).multiplyScalar(t)\n            );\n\n    this.uv.add(\n            a.uv.clone().sub(this.uv).multiplyScalar(t)\n            );\n\n    return this;\n};\nThreeBSP.Vertex.prototype.interpolate = function(other, t) {\n    return this.clone().lerp(other, t);\n};\nThreeBSP.Vertex.prototype.applyMatrix4 = function(m) {\n\n    // input: THREE.Matrix4 affine matrix\n\n    var x = this.x, y = this.y, z = this.z;\n\n    var e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n    return this;\n\n}\n\n\nThreeBSP.Node = function(polygons) {\n    var i, polygon_count,\n            front = [],\n            back = [];\n\n    this.polygons = [];\n    this.front = this.back = undefined;\n\n    if (!(polygons instanceof Array) || polygons.length === 0)\n        return;\n\n    this.divider = polygons[0].clone();\n\n    for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n        this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n\n    if (front.length > 0) {\n        this.front = new ThreeBSP.Node(front);\n    }\n\n    if (back.length > 0) {\n        this.back = new ThreeBSP.Node(back);\n    }\n};\nThreeBSP.Node.isConvex = function(polygons) {\n    var i, j;\n    for (i = 0; i < polygons.length; i++) {\n        for (j = 0; j < polygons.length; j++) {\n            if (i !== j && polygons[i].classifySide(polygons[j]) !== BACK) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nThreeBSP.Node.prototype.build = function(polygons) {\n    var i, polygon_count,\n            front = [],\n            back = [];\n\n    if (!this.divider) {\n        this.divider = polygons[0].clone();\n    }\n\n    for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n        this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n\n    if (front.length > 0) {\n        if (!this.front)\n            this.front = new ThreeBSP.Node();\n        this.front.build(front);\n    }\n\n    if (back.length > 0) {\n        if (!this.back)\n            this.back = new ThreeBSP.Node();\n        this.back.build(back);\n    }\n};\nThreeBSP.Node.prototype.allPolygons = function() {\n    var polygons = this.polygons.slice();\n    if (this.front)\n        polygons = polygons.concat(this.front.allPolygons());\n    if (this.back)\n        polygons = polygons.concat(this.back.allPolygons());\n    return polygons;\n};\nThreeBSP.Node.prototype.clone = function() {\n    var node = new ThreeBSP.Node();\n\n    node.divider = this.divider.clone();\n    node.polygons = this.polygons.map(function(polygon) {\n        return polygon.clone();\n    });\n    node.front = this.front && this.front.clone();\n    node.back = this.back && this.back.clone();\n\n    return node;\n};\nThreeBSP.Node.prototype.invert = function() {\n    var i, polygon_count, temp;\n\n    for (i = 0, polygon_count = this.polygons.length; i < polygon_count; i++) {\n        this.polygons[i].flip();\n    }\n\n    this.divider.flip();\n    if (this.front)\n        this.front.invert();\n    if (this.back)\n        this.back.invert();\n\n    temp = this.front;\n    this.front = this.back;\n    this.back = temp;\n\n    return this;\n};\nThreeBSP.Node.prototype.clipPolygons = function(polygons) {\n    var i, polygon_count,\n            front, back;\n\n    if (!this.divider)\n        return polygons.slice();\n\n    front = [], back = [];\n\n    for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n        this.divider.splitPolygon(polygons[i], front, back, front, back);\n    }\n\n    if (this.front)\n        front = this.front.clipPolygons(front);\n    if (this.back)\n        back = this.back.clipPolygons(back);\n    else\n        back = [];\n\n    return front.concat(back);\n};\n\nThreeBSP.Node.prototype.clipTo = function(node) {\n    this.polygons = node.clipPolygons(this.polygons);\n    if (this.front)\n        this.front.clipTo(node);\n    if (this.back)\n        this.back.clipTo(node);\n};\n\n\n"]}