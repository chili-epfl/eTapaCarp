{"version":3,"file":"/packages/ToolManager.js","sources":["ToolManager/Tool.js","ToolManager/ToolManager.js"],"names":[],"mappings":";;;;;;;;AAAA,0B;AACA,2D;AACA,qB;AACA,8D;AACA,K;AACA,C;AACA,4C;AACA,iB;AACA,qC;AACA,kB;AACA,c;AACA,oB;AACA,yB;AACA,C;;AAEA,wD;AACA,sE;AACA,iC;AACA,mC;;AAEA,C;AACA,yC;;AAEA,C;AACA,uD;AACA,C;AACA,qD;AACA,C;AACA,mC;AACA,E;;AAEA,mD;AACA,+C;AACA,qB;AACA,qB;AACA,yB;AACA,6B;AACA,0B;AACA,wI;AACA,4O;AACA,sG;;AAEA,0B;AACA,mB;AACA,uB;AACA,6B;AACA,sC;;AAEA,2B;;AAEA,mB;AACA,kB;AACA,kB;AACA,kB;AACA,kB;AACA,kB;AACA,kB;AACA,kB;AACA,kB;AACA,iB;AACA,K;;AAEA,E;AACA,mC;AACA,gD;AACA,+D;AACA,2D;AACA,iC;AACA,4C;AACA,gD;AACA,4D;;AAEA,S;AACA,K;AACA,wC;AACA,mC;;AAEA,C;AACA,gD;AACA,kF;AACA,kF;AACA,0F;;AAEA,mB;AACA,sB;AACA,wB;AACA,sE;AACA,+D;AACA,gE;AACA,4B;AACA,yC;AACA,4D;AACA,8D;;AAEA,K;AACA,U;AACA,iE;AACA,oE;AACA,K;AACA,mD;AACA,mD;AACA,qE;AACA,sE;;AAEA,yC;AACA,gE;AACA,kE;;AAEA,K;AACA,U;AACA,qE;AACA,wE;AACA,K;;AAEA,qD;AACA,qD;AACA,0G;;AAEA,sE;AACA,0D;;;AAGA,yC;AACA,8D;AACA,+D;AACA,kE;AACA,iE;;AAEA,uD;AACA,uD;;AAEA,iD;AACA,mE;AACA,kE;AACA,6C;AACA,iF;AACA,kD;;AAEA,mO;AACA,oO;;;AAGA,wD;AACA,yD;AACA,8D;AACA,qF;AACA,2B;AACA,a;AACA,6D;AACA,kC;AACA,mC;;AAEA,iB;AACA,E;;AAEA,0C;AACA,6B;AACA,6B;AACA,6B;AACA,6B;AACA,6B;AACA,6B;AACA,mC;AACA,kC;AACA,kC;AACA,kC;AACA,kC;AACA,kC;AACA,kC;AACA,mC;;;AAGA,C;;AAEA,8D;AACA,iB;AACA,wB;AACA,sB;AACA,wB;AACA,sE;AACA,+D;AACA,gE;AACA,4B;AACA,yC;AACA,4D;AACA,8D;;AAEA,K;AACA,U;AACA,4B;AACA,iE;AACA,oE;AACA,K;AACA,mD;AACA,mD;AACA,qE;AACA,sE;AACA,yC;AACA,gE;AACA,kE;;AAEA,K;AACA,U;AACA,4B;;AAEA,qE;AACA,wE;AACA,K;AACA,qD;AACA,qD;;;AAGA,qD;AACA,qD;;;AAGA,wC;AACA,wC;;AAEA,6C;AACA,6C;AACA,iB;;AAEA,0C;AACA,0C;AACA,wC;;AAEA,gC;AACA,sC;;;AAGA,qC;AACA,kB;AACA,iC;AACA,4E;AACA,6E;AACA,0C;AACA,6C;AACA,2E;AACA,6E;;AAEA,gB;AACA,mG;AACA,sG;AACA,S;;AAEA,qD;AACA,qD;AACA,4C;AACA,sC;AACA,mG;AACA,sD;AACA,2D;AACA,oB;AACA,6E;AACA,6D;AACA,oB;AACA,6E;AACA,qF;AACA,a;AACA,2D;AACA,sB;AACA,6E;AACA,sF;AACA,oB;AACA,6E;AACA,iE;AACA,a;AACA,8B;AACA,0D;AACA,+C;AACA,0C;AACA,+B;AACA,a;;AAEA,6C;AACA,mC;AACA,mC;AACA,uC;AACA,kC;;AAEA,mC;AACA,uC;;AAEA,qD;AACA,mD;AACA,sG;AACA,S;AACA,Y;AACA,oD;AACA,mD;;AAEA,2B;AACA,4C;AACA,qC;AACA,+C;AACA,sC;AACA,0C;AACA,2C;AACA,gF;;AAEA,K;AACA,U;AACA,+B;AACA,gD;AACA,4C;AACA,K;AACA,mE;AACA,kB;AACA,mC;AACA,kF;AACA,mF;AACA,8C;AACA,6C;AACA,iF;AACA,mF;;AAEA,gB;AACA,uB;AACA,uF;AACA,0F;AACA,S;;AAEA,uE;AACA,sE;;;AAGA,kC;AACA,+E;AACA,gF;AACA,4C;AACA,6C;AACA,8E;AACA,gF;;AAEA,gB;AACA,uB;AACA,oF;AACA,uF;AACA,S;;AAEA,uE;AACA,uE;AACA,sH;AACA,wC;AACA,mC;AACA,oD;AACA,yG;AACA,S;AACA,c;AACA,mK;;AAEA,S;AACA,2C;AACA,sB;AACA,kC;AACA,a;AACA,2B;AACA,K;AACA,U;AACA,4C;AACA,K;AACA,E;AACA,sE;AACA,sC;AACA,kC;AACA,0C;AACA,K;;AAEA,iD;AACA,8D;AACA,sF;AACA,8E;AACA,a;AACA,mC;AACA,a;AACA,C;;AAEA,kE;AACA,oE;AACA,uC;AACA,mD;AACA,iC;AACA,K;AACA,sB;AACA,oE;AACA,0C;AACA,qC;AACA,8C;AACA,oD;AACA,8D;AACA,a;AACA,S;AACA,8B;AACA,uF;AACA,iD;AACA,iD;AACA,iD;AACA,sC;AACA,qE;AACA,0D;AACA,6D;AACA,mC;AACA,2C;AACA,gF;AACA,iH;AACA,yD;AACA,yD;AACA,kE;AACA,iC;AACA,qB;;;AAGA,+C;AACA,0F;AACA,0D;AACA,0H;AACA,wD;AACA,8D;AACA,mE;AACA,2D;AACA,yB;;AAEA,qB;AACA,4D;AACA,wD;AACA,mF;AACA,4D;AACA,2D;AACA,kF;;AAEA,yB;AACA,kF;AACA,6E;AACA,2D;AACA,2B;AACA,E;AACA,oF;AACA,8D;AACA,4D;AACA,0C;AACA,6E;AACA,4D;AACA,0F;AACA,4D;;AAEA,mD;AACA,kD;AACA,4B;AACA,qD;;AAEA,oD;AACA,qB;AACA,iB;AACA,wC;AACA,+C;AACA,qD;AACA,yD;AACA,0B;AACA,4C;AACA,oE;AACA,mB;AACA,a;AACA,S;AACA,K;AACA,oB;AACA,0D;AACA,sC;AACA,+B;AACA,kC;AACA,uF;AACA,iD;AACA,iD;AACA,iD;AACA,sC;AACA,qE;AACA,4B;AACA,4D;AACA,Y;AACA,0D;AACA,6D;AACA,mC;AACA,8D;AACA,2C;AACA,6D;AACA,6D;AACA,+C;AACA,kE;AACA,yD;AACA,kD;AACA,uB;AACA,6B;AACA,iB;;;AAGA,iD;;AAEA,gF;AACA,iH;AACA,yD;AACA,+D;AACA,gF;AACA,kD;AACA,kD;AACA,yD;AACA,uF;AACA,yE;AACA,gD;AACA,gD;AACA,+C;AACA,0F;AACA,0D;AACA,0H;AACA,wD;AACA,2D;AACA,kC;AACA,0E;AACA,qE;AACA,iC;AACA,yB;AACA,mE;AACA,qD;AACA,wE;AACA,wF;AACA,+E;AACA,wE;AACA,6B;AACA,yB;AACA,4E;AACA,8B;AACA,yE;AACA,2D;AACA,kD;AACA,wD;AACA,6B;AACA,kC;AACA,2D;AACA,kD;AACA,wD;AACA,6B;AACA,yB;AACA,qB;AACA,gF;AACA,4D;AACA,wD;AACA,kF;AACA,2D;AACA,oF;AACA,+D;AACA,yE;AACA,0E;AACA,0E;AACA,4F;AACA,6B;AACA,0E;AACA,iE;AACA,0D;AACA,8B;AACA,kC;AACA,yB;AACA,0E;AACA,2D;AACA,0F;AACA,+D;AACA,yE;AACA,0E;AACA,0E;AACA,4F;AACA,6B;AACA,qF;AACA,iE;AACA,0D;AACA,+B;AACA,kC;AACA,yB;AACA,+C;AACA,2C;AACA,4C;AACA,gE;AACA,yD;AACA,uE;AACA,iE;AACA,iE;AACA,gD;AACA,6B;AACA,6D;AACA,yB;AACA,mE;AACA,gD;;AAEA,wG;AACA,2D;AACA,qE;AACA,sE;AACA,sE;AACA,wF;AACA,yB;;;AAGA,kF;AACA,mL;AACA,yK;;AAEA,uD;AACA,4G;AACA,uD;AACA,oH;AACA,kH;AACA,4G;AACA,yD;AACA,2D;AACA,4D;AACA,yE;AACA,uE;AACA,0C;AACA,wF;AACA,iC;AACA,sC;AACA,+C;;;AAGA,0H;AACA,yF;AACA,2D;AACA,8C;AACA,sD;AACA,wE;AACA,E;AACA,yB;;AAEA,oD;;AAEA,mD;;AAEA,oF;AACA,qE;AACA,8B;AACA,qE;AACA,wE;;AAEA,kD;AACA,kD;;AAEA,yH;AACA,iE;AACA,iE;AACA,0E;AACA,wG;AACA,8G;AACA,sG;AACA,0G;;AAEA,uG;AACA,qG;AACA,+E;AACA,4E;AACA,wD;AACA,sF;AACA,uH;AACA,oC;AACA,yH;;AAEA,6B;AACA,yE;AACA,qE;AACA,8E;AACA,wD;AACA,2E;AACA,oE;AACA,kE;;AAEA,iC;AACA,0E;AACA,4E;AACA,oE;AACA,kE;AACA,iC;;AAEA,6B;AACA,uE;AACA,uE;AACA,8E;AACA,wD;AACA,2E;AACA,oE;AACA,kE;;AAEA,iC;AACA,4E;AACA,4E;AACA,oE;AACA,kE;AACA,iC;AACA,6B;AACA,wE;AACA,0E;AACA,oD;AACA,uE;AACA,gE;AACA,+D;AACA,8D;AACA,+D;;AAEA,6B;AACA,wE;AACA,wE;AACA,gE;AACA,+D;AACA,8D;AACA,+D;AACA,6B;;AAEA,wD;AACA,wD;;AAEA,yB;;AAEA,2F;AACA,6G;AACA,qF;AACA,qF;;AAEA,2E;AACA,yE;AACA,4E;;AAEA,iC;AACA,uE;AACA,wE;AACA,iC;AACA,4E;AACA,2E;AACA,iC;AACA,oF;AACA,0E;AACA,iD;AACA,6B;AACA,yB;;AAEA,6E;AACA,8F;AACA,0E;AACA,oG;AACA,sD;AACA,yB;AACA,8F;AACA,0E;AACA,oG;AACA,yD;AACA,yB;;AAEA,6I;AACA,sD;AACA,qD;AACA,wD;AACA,8E;AACA,oD;AACA,iD;AACA,gE;AACA,yB;AACA,qF;;AAEA,qB;AACA,iB;;AAEA,oD;AACA,8E;AACA,sC;AACA,4C;AACA,qD;AACA,yD;AACA,sB;AACA,oE;AACA,a;AACA,S;AACA,kC;AACA,K;;AAEA,C;;AAEA,2C;AACA,iF;AACA,uC;AACA,oB;AACA,yD;AACA,2B;;AAEA,0F;AACA,gE;AACA,gD;AACA,0G;AACA,wC;AACA,sD;AACA,+F;AACA,kF;AACA,S;AACA,K;;AAEA,uC;AACA,0E;AACA,0C;AACA,qB;AACA,0E;AACA,4B;AACA,wG;AACA,yD;AACA,6E;AACA,8D;AACA,oC;AACA,oC;;AAEA,a;AACA,2B;AACA,uB;AACA,S;AACA,qB;AACA,wB;;AAEA,K;AACA,iB;AACA,C;AACA,wE;;AAEA,8E;AACA,6C;AACA,8E;AACA,yB;AACA,gG;AACA,uE;AACA,+D;AACA,mE;AACA,2B;AACA,iB;AACA,a;AACA,2B;AACA,6B;AACA,uH;AACA,4B;AACA,a;AACA,S;AACA,K;AACA,iB;;AAEA,C;;AAEA,gI;AACA,kE;AACA,+B;AACA,gC;AACA,gC;;AAEA,0E;AACA,iC;AACA,uE;AACA,+C;AACA,kD;AACA,K;;AAEA,uF;AACA,oF;AACA,kF;AACA,2E;AACA,8B;AACA,qD;AACA,4G;AACA,6H;AACA,gC;AACA,iB;AACA,a;AACA,iC;AACA,6E;AACA,sF;AACA,sF;;AAEA,gF;AACA,+B;AACA,iH;AACA,iG;AACA,+F;AACA,uC;;AAEA,oH;AACA,uI;AACA,yC;AACA,yB;AACA,qB;AACA,0C;AACA,mC;AACA,4D;AACA,2F;AACA,2F;AACA,+E;AACA,4C;AACA,qB;AACA,iB;;AAEA,a;;AAEA,S;AACA,K;;AAEA,mE;AACA,+B;AACA,gC;AACA,uF;AACA,kE;AACA,mE;AACA,K;AACA,6B;AACA,8B;;AAEA,0B;AACA,qD;AACA,uC;AACA,mC;AACA,S;AACA,K;AACA,qD;AACA,uC;AACA,mC;AACA,S;AACA,K;;AAEA,sC;AACA,wE;AACA,wC;AACA,uD;AACA,K;AACA,wE;AACA,wC;AACA,uD;AACA,K;AACA,4C;;AAEA,C;;AAEA,qD;AACA,6C;AACA,yB;AACA,iC;AACA,yE;AACA,0B;AACA,2F;AACA,8D;AACA,+B;AACA,sB;AACA,a;AACA,S;AACA,mB;AACA,+C;AACA,K;AACA,kD;;AAEA,uB;;;AAGA,kC;AACA,c;;AAEA,6E;;AAEA,c;AACA,wF;AACA,4E;AACA,wD;AACA,K;AACA,wD;AACA,0C;;AAEA,6B;;AAEA,8B;AACA,gC;AACA,oD;AACA,0B;AACA,qC;AACA,qC;AACA,qC;AACA,K;AACA,uB;AACA,kG;AACA,4C;AACA,4C;AACA,K;AACA,U;AACA,kE;AACA,8C;AACA,K;AACA,gC;AACA,gC;AACA,oD;;AAEA,oC;AACA,4E;AACA,uC;AACA,mD;AACA,oC;AACA,8E;AACA,K;;AAEA,+C;AACA,uC;AACA,oC;AACA,O;;;;;;AAMA,oD;AACA,kD;AACA,K;AACA,mB;AACA,C;;AAEA,qE;;AAEA,sD;AACA,kD;;AAEA,kC;AACA,sB;AACA,gC;AACA,oB;;AAEA,4E;AACA,C;;AAEA,yE;AACA,uC;AACA,oB;;AAEA,iB;AACA,C;;;AAGA,C;;;;;;;;;;;;;;;;;;AC5gCA,yB;AACA,iB;AACA,C;;AAEA,+C;AACA,+B;AACA,E;;AAEA,iE;AACA,qD;AACA,wE;AACA,yE;AACA,uE;AACA,0E;AACA,iB;AACA,uC;AACA,uC;AACA,qC;AACA,+D;AACA,qD;AACA,K;AACA,S;AACA,qD;AACA,K;AACA,oC;AACA,G","sourcesContent":["ToolFactory = function() {\n    this.createTool = function(id, brickManager, markers) {\n        if (id == 83)\n            return new PlaneCutter(id, brickManager, markers);\n    }\n}\nTool = function(id, brickManager, markers) {\n    this.id = id;\n    this.brickManager = brickManager;\n    this.geometry;\n    this.mesh;\n    this.visibility;\n    //this.init(markers);\n}\n\nTool.prototype.changeVisibility = function(visibility) {\n    Logger.postEvent(\"Tool:\" + this.id + \";visibility:\" + visibility);\n    this.visibility = visibility;\n    this.mesh.visible = visibility;\n\n}\nTool.prototype.init = function(markers) {\n\n}\nTool.prototype.computeNewPosition = function(markers) {\n}\nTool.prototype.computeNewStatus = function(markers) {\n}\nTool.prototype.reset = function() {\n};\n\nPlaneCutter = function(id, brickManager, markers) {\n    Tool.call(this, id, brickManager, markers);\n    this.minDistance;\n    this.maxDistance;\n    this.rotationMarkerZ;\n    this.cutAvailable = true;\n    this.horizMesh = null;\n    this.SimLineDashMaterial = new THREE.LineDashedMaterial({color: 0xff1919, gapSize: 4, dashSize: 4, linewidth: 3, depthTest: false});\n    this.SimMeshMaterial = new THREE.MeshBasicMaterial({color: 0xffec45, depthWrite: false, depthTest: false, transparent: true, opacity: 0.5, side: THREE.DoubleSide, polygonOffset: true, polygonOffsetFactor: 2, polygonOffsetUnits: 2});\n    this.lineMaterial = new THREE.LineBasicMaterial({color: 0x000000, depthTest: true, linewidth: 2});\n\n    this.selection = null;\n    this.floorLine;\n    this.init(markers);\n    this.lastInclination = 0;\n    this.lastZ = this.mesh.position.z;\n\n    this.testOldRot = null;\n\n    this.colors = [\n        '#ffd070',\n        '#e6ff6f',\n        '#ff886f',\n        '#6f9eff',\n        '#80ff00',\n        '#00ff8e',\n        '#00b6ae',\n        '#e08e66',\n        '#0082a5'\n    ]\n\n};\nPlaneCutter.prototype = new Tool();\nPlaneCutter.prototype.constructor = PlaneCutter;\nPlaneCutter.prototype.changeVisibility = function(visibility) {\n    Tool.prototype.changeVisibility.call(this, visibility);\n    if (this.selection != null) {\n        this.selection.visible = visibility;\n        for (var i in this.selection.children) {\n            this.selection.children[i].visible = visibility;\n\n        }\n    }\n    this.floorLine.visible = visibility;\n    this.horizMesh.visible = false;\n\n}\nPlaneCutter.prototype.init = function(markers) {\n    this.minDistance = Session.get('tools')[this.id]['extra_info']['minDistance'];\n    this.maxDistance = Session.get('tools')[this.id]['extra_info']['maxDistance'];\n    this.rotationMarkerZ = Session.get('tools')[this.id]['extra_info']['rotationMarkerZ'];\n\n    var mUp, mDown;\n    mUp = markers[41];\n    mDown = markers[42];\n    //Take the 2 opposite corners of the marker and compute the center\n    var mUp_position = [mUp.corners[0].x, mUp.corners[0].y, 1];\n    var mUp_position2 = [mUp.corners[2].x, mUp.corners[2].y, 1];\n    var position, position2;\n    if (Session.get('virtual') == true) {\n        position = {x: mUp_position[0], y: mUp_position[1]};\n        position2 = {x: mUp_position2[0], y: mUp_position2[1]}\n\n    }\n    else {\n        position = pixel2mm(mUp_position[0], mUp_position[1], 1);\n        position2 = pixel2mm(mUp_position2[0], mUp_position2[1], 1);\n    }\n    var centerUpX = (position.x + position2.x) / 2;\n    var centerUpY = (position.y + position2.y) / 2;\n    var mDown_position = [mDown.corners[0].x, mDown.corners[0].y, 1];\n    var mDown_position2 = [mDown.corners[2].x, mDown.corners[2].y, 1];\n\n    if (Session.get('virtual') == true) {\n        position = {x: mDown_position[0], y: mDown_position[1]};\n        position2 = {x: mDown_position2[0], y: mDown_position2[1]}\n\n    }\n    else {\n        position = pixel2mm(mDown_position[0], mDown_position[1], 1);\n        position2 = pixel2mm(mDown_position2[0], mDown_position2[1], 1);\n    }\n\n    var centerDownX = (position.x + position2.x) / 2;\n    var centerDownY = (position.y + position2.y) / 2;\n    var distance = Math.sqrt(Math.pow(centerDownX - centerUpX, 2) + Math.pow(centerUpY - centerDownY, 2));\n\n    //this.geometry = new THREE.PlaneGeometry(distance / 2, distance);\n    var horizGeometry = new THREE.PlaneGeometry(200, 400);\n\n\n    this.geometry = new THREE.Geometry();\n    this.geometry.vertices.push(new THREE.Vector3(0, 200, 0));\n    this.geometry.vertices.push(new THREE.Vector3(0, -200, 0));\n    this.geometry.vertices.push(new THREE.Vector3(-200, -200, 0));\n    this.geometry.vertices.push(new THREE.Vector3(-200, 200, 0));\n\n    this.geometry.faces.push(new THREE.Face3(0, 1, 2));\n    this.geometry.faces.push(new THREE.Face3(0, 2, 3));\n\n    var floorLineGeometry = new THREE.Geometry();\n    floorLineGeometry.vertices.push(new THREE.Vector3(0, -200, 0));\n    floorLineGeometry.vertices.push(new THREE.Vector3(0, 200, 0));\n    floorLineGeometry.computeLineDistances();\n    this.floorLine = new THREE.Line(floorLineGeometry, this.SimLineDashMaterial);\n    this.floorLine.renderDepth = 9007199254740992;\n\n    var material = new THREE.MeshBasicMaterial({color: 0xffec45, side: THREE.DoubleSide, transparent: true, opacity: 0.4, depthWrite: false, depthTest: false, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1})\n    var material2 = new THREE.MeshBasicMaterial({color: 0xC1FFC1, side: THREE.DoubleSide, transparent: true, opacity: 0.4, depthWrite: false, depthTest: false, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1})\n\n\n    this.mesh = new THREE.Mesh(this.geometry, material);\n    Logger.postEvent(\"Plane-Cutter-Created;TopMarker:(\" +\n            centerUpX + \",\" + centerUpY + \");BottomMarker:(\" +\n            centerDownX + \",\" + centerDownY + \");RotationRad:\" + 0+\";RotationDeg:\"+ 0\n            +\";Height:\" + 0\n            )\n    this.horizMesh = new THREE.Mesh(horizGeometry, material2)\n    this.mesh.add(this.horizMesh);\n    this.horizMesh.visible = false;\n\n    this.reset();\n};\n\nPlaneCutter.prototype.reset = function() {\n    this.mesh.rotation.x = 0;\n    this.mesh.rotation.y = 0;\n    this.mesh.rotation.z = 0;\n    this.mesh.position.x = 0;\n    this.mesh.position.y = 0;\n    this.mesh.position.z = 0;\n    this.mesh.rotateY(Math.PI / 2);\n    this.floorLine.rotation.x = 0;\n    this.floorLine.rotation.y = 0;\n    this.floorLine.rotation.z = 0;\n    this.floorLine.position.x = 0;\n    this.floorLine.position.y = 0;\n    this.floorLine.position.z = 0;\n    this.horizMesh.visible = false;\n\n\n}\n\nPlaneCutter.prototype.computeNewPosition = function(markers) {\n    this.reset();\n    var mUp, mDown,text;\n    mUp = markers[41];\n    mDown = markers[42];\n    //Take the 2 opposite corners of the marker and compute the center\n    var mUp_position = [mUp.corners[0].x, mUp.corners[0].y, 1];\n    var mUp_position2 = [mUp.corners[2].x, mUp.corners[2].y, 1];\n    var position, position2;\n    if (Session.get('virtual') == true) {\n        position = {x: mUp_position[0], y: mUp_position[1]};\n        position2 = {x: mUp_position2[0], y: mUp_position2[1]}\n\n    }\n    else {\n        //Hard Coding Height\n        position = pixel2mm(mUp_position[0], mUp_position[1], 5);\n        position2 = pixel2mm(mUp_position2[0], mUp_position2[1], 5);\n    }\n    var centerUpX = (position.x + position2.x) / 2;\n    var centerUpY = (position.y + position2.y) / 2;\n    var mDown_position = [mDown.corners[0].x, mDown.corners[0].y, 1];\n    var mDown_position2 = [mDown.corners[2].x, mDown.corners[2].y, 1];\n    if (Session.get('virtual') == true) {\n        position = {x: mDown_position[0], y: mDown_position[1]};\n        position2 = {x: mDown_position2[0], y: mDown_position2[1]}\n\n    }\n    else {\n        //Hard Coding Height\n\n        position = pixel2mm(mDown_position[0], mDown_position[1], 5);\n        position2 = pixel2mm(mDown_position2[0], mDown_position2[1], 5);\n    }\n    var centerDownX = (position.x + position2.x) / 2;\n    var centerDownY = (position.y + position2.y) / 2;\n\n\n    var planeCenterX = (centerUpX + centerDownX) / 2;\n    var planeCenterY = (centerUpY + centerDownY) / 2;\n\n\n    this.mesh.position.x = planeCenterX;\n    this.mesh.position.y = planeCenterY;\n\n    this.floorLine.position.x = planeCenterX;\n    this.floorLine.position.y = planeCenterY;\n    var rotation;\n\n    var diffx = (centerUpX - centerDownX);\n    var diffy = (centerUpY - centerDownY);\n    rotation = Math.atan2(diffx, diffy);\n\n    this.mesh.rotateX(rotation);\n    this.floorLine.rotateZ(-rotation);\n\n\n    if (markers.hasOwnProperty(45)) {\n        //Rotation\n        var marker = markers[45];\n        var marker_position = [marker.corners[0].x, marker.corners[0].y, 1];\n        var marker_position2 = [marker.corners[1].x, marker.corners[1].y, 1];\n        var real_position, real_position2;\n        if (Session.get('virtual') == true) {\n            real_position = {x: marker_position[0], y: marker_position[1]};\n            real_position2 = {x: marker_position2[0], y: marker_position2[1]}\n\n        } else {\n            real_position = pixel2mm(marker_position[0], marker_position[1], this.rotationMarkerZ);\n            real_position2 = pixel2mm(marker_position2[0], marker_position2[1], this.rotationMarkerZ);\n        }\n\n        diffx = (real_position.x - real_position2.x);\n        diffy = (real_position.y - real_position2.y);\n        rotation = Math.atan2(diffy, diffx);\n        if (this.testOldRot != null) {\n            if ((this.testOldRot >= 0 && rotation >= 0) || (this.testOldRot <= 0 && rotation <= 0))\n                rotation = rotation - this.testOldRot;\n            else if (this.testOldRot > 0 && rotation < 0) {\n                //--\n                if (this.testOldRot < Math.PI / 2 && rotation > -Math.PI / 2)\n                    rotation = (-this.testOldRot + rotation);\n                //++\n                if (this.testOldRot > Math.PI / 2 && rotation < -Math.PI / 2)\n                    rotation = ((Math.PI - this.testOldRot) - (-Math.PI - rotation));\n            }\n            else if (this.testOldRot < 0 && rotation > 0) {\n                //--  \n                if (this.testOldRot < -Math.PI / 2 && rotation > Math.PI / 2)\n                    rotation = ((-Math.PI - this.testOldRot) + (-Math.PI + rotation));\n                //++\n                if (this.testOldRot > -Math.PI / 2 && rotation < Math.PI / 2)\n                    rotation = ((-this.testOldRot) + (rotation));\n            }\n            if (rotation != 0)\n                rotation = Math.round(rotation / 0.03490);\n            var val = rotation * -0.0174532925;\n            if (centerUpY < centerDownY) {\n                val = val * -1;\n            }\n\n            val = this.lastInclination + val;\n            if (val < -Math.PI / 2)\n                val = -Math.PI / 2;\n            else if (val > Math.PI / 2)\n                val = Math.PI / 2;\n\n            this.mesh.rotateY(val);\n            this.lastInclination = val;\n\n            $(\"label[for='Degrees-Plane']\").empty( );\n            text = Math.round(val / -0.0174532925);\n            $(\"label[for='Degrees-Plane']\").append(\"Plane Inclination:<strong>\" + text + \"</strong>\");\n        }\n        else\n            this.mesh.rotateY(this.lastInclination);\n        this.testOldRot = Math.atan2(diffy, diffx);\n\n//        if (rotation < 0)\n//            rotation = Math.PI + rotation;\n//        if (rotation > Math.PI / 2)\n//            rotation = -(Math.PI - rotation);\n//        this.mesh.rotateY(rotation);\n//        this.lastInclination = rotation;\n//        console.log(this.lastInclination)\n//        //Translantion && (rotation<Math.PI/2+0.44 && rotation>Math.PI/2-0.44)\n\n    }\n    else {\n        this.testOldRot = null;\n        this.mesh.rotateY(this.lastInclination);\n        //this.mesh.position.z = this.lastZ;\n    }\n    if (markers.hasOwnProperty(39) && markers.hasOwnProperty(38)) {\n        //39 moves\n        var markerT1 = markers[38];\n        var markerT1_position = [markerT1.corners[0].x, markerT1.corners[0].y, 1];\n        var markerT1_position2 = [markerT1.corners[1].x, markerT1.corners[1].y, 1];\n        var T1real_position, T1real_position2;\n        if (Session.get('virtual') == true) {\n            T1real_position = {x: markerT1_position[0], y: markerT1_position[1]};\n            T1real_position2 = {x: markerT1_position2[0], y: markerT1_position2[1]}\n\n        } else {\n            //Hard code\n            T1real_position = pixel2mm(markerT1_position[0], markerT1_position[1], 25);\n            T1real_position2 = pixel2mm(markerT1_position2[0], markerT1_position2[1], 25);\n        }\n\n        var centroidUpX = (T1real_position.x + T1real_position2.x) / 2;\n        var centroidUpY = (T1real_position.y + T1real_position2.y) / 2\n\n\n        var markerT = markers[39];\n        var markerT_position = [markerT.corners[0].x, markerT.corners[0].y, 1];\n        var markerT_position2 = [markerT.corners[1].x, markerT.corners[1].y, 1];\n        var Treal_position, Treal_position2;\n        if (Session.get('virtual') == true) {\n            Treal_position = {x: markerT_position[0], y: markerT_position[1]};\n            Treal_position2 = {x: markerT_position2[0], y: markerT_position2[1]}\n\n        } else {\n            //Hard Code\n            Treal_position = pixel2mm(markerT_position[0], markerT_position[1], 50);\n            Treal_position2 = pixel2mm(markerT_position2[0], markerT_position2[1], 50);\n        }\n\n        var centroidDownX = (Treal_position.x + Treal_position2.x) / 2;\n        var centroidDownY = (Treal_position.y + Treal_position2.y) / 2;\n        var distance = Math.sqrt(Math.pow(centroidDownX - centroidUpX, 2) + Math.pow(centroidDownY - centroidUpY, 2));\n        distance = Math.round(distance);\n        //TODO:Set session variable\n        if (Session.get('maxBrickZ') == undefined) {\n            distance = 95 * ((distance - this.minDistance) / (this.maxDistance - this.minDistance)) - 20;\n        }\n        else {\n            distance = (Session.get('maxBrickZ') + Session.get('maxBrickZ') * 0.25) * ((distance - this.minDistance) / (this.maxDistance - this.minDistance)) - 20;\n\n        }\n        //console.log(\"Distance:\"+distance)\n        if(distance>0)\n            this.lastZ = distance;\n        else \n            this.lastZ = 0;\n    }\n    else {\n//        this.mesh.position.z = this.lastZ;\n    }\n//\n    if (this.lastInclination > 1.50 || this.lastInclination < -1.50) {\n        this.horizMesh.visible = true;\n        this.mesh.visible = false;\n        this.mesh.position.z = this.lastZ;\n    }\n\n    Logger.postEvent(\"Plane-Cutter;TopMarker:(\" +\n            centerUpX + \",\" + centerUpY + \");BottomMarker:(\" +\n            centerDownX + \",\" + centerDownY + \");RotationRad:\" + this.lastInclination \n            +\";RotationDeg:\"+ Math.round(this.lastInclination / -0.0174532925)\n            +\n            \";Height:\" + this.lastZ\n            )\n}\n\nPlaneCutter.prototype.computeNewStatus = function(markers, view) {\n    if (markers.hasOwnProperty(43) && !markers.hasOwnProperty(40)) {\n        if (this.cutAvailable == false)\n            Logger.postEvent(\"Enabling the Cut...\")\n        this.cutAvailable = true;\n    }\n    /*Simulate a cut*/\n    if (!markers.hasOwnProperty(40) || this.cutAvailable == false) {\n        view.scene.remove(this.selection);\n        if (this.selection != null) {\n            this.selection.geometry.dispose();\n            for (var i in this.selection.children) {\n                this.selection.children[i].geometry.dispose();\n            }\n        }\n        this.selection = null;\n        var points = THREE.GeometryUtils.randomPointsInGeometry(this.mesh.geometry, 3);\n        points[0].applyMatrix4(this.mesh.matrix);\n        points[1].applyMatrix4(this.mesh.matrix);\n        points[2].applyMatrix4(this.mesh.matrix);\n        var plane = new THREE.Plane();\n        plane.setFromCoplanarPoints(points[0], points[1], points[2]);\n        for (var brickIndex in this.brickManager.bricks) {\n            var brick = this.brickManager.bricks[brickIndex];\n            if (brick.visibility) {\n                brick.faces.updateMatrix();\n                /*In thise way we avoid to take into account the new blocks :)*/\n                for (var blockIndex = 0, numBlocks = brick.blocks.length; blockIndex < numBlocks; blockIndex++) {\n                    var block = brick.blocks[blockIndex];\n                    var intersectionPoints = new Array();\n                    if (this.checkFaceCut2(brick, plane, false)) {\n                        continue;\n                    }\n\n\n                    /*Find intersection point*/\n                    for (var lineIndex = 0; lineIndex < block.lines.length; lineIndex++) {\n                        var line = block.lines[lineIndex];\n                        var line3 = new THREE.Line3(line.geometry.vertices[0].clone(), line.geometry.vertices[1].clone());\n                        line3.applyMatrix4(line.matrix);\n                        if (plane.isIntersectionLine(line3)) {\n                            var point = plane.intersectLine(line3);\n                            intersectionPoints.push(point);\n                        }\n\n                    }\n                    /*I've got the intersection points :) */\n                    if (intersectionPoints.length > 1) {\n                        intersectionPoints = this.sortVertices(intersectionPoints);\n                        var geometry = new THREE.Geometry();\n                        for (var i in intersectionPoints) {\n                            geometry.vertices.push(intersectionPoints[i].clone());\n\n                        }\n//                        for (var k = 0; k < geometry.vertices.length - 2; k++) {\n//                            var newFace = new THREE.Face3(0, k + 1, k + 2);\n//                            geometry.faces.push(newFace);\n//                        }\n//\n//                        var face = new THREE.Mesh(geometry, this.SimMeshMaterial);\n//                        face.renderDepth = 9007199254740992;\n                        var lineGeometry = geometry.clone();\n                        /*Close the line*/\n                        lineGeometry.vertices.push(lineGeometry.vertices[0]);\n                        lineGeometry.computeLineDistances();\n                        var line = new THREE.Line(lineGeometry, this.SimLineDashMaterial);\n                        line.renderDepth = 9007199254740992;\n\n                        if (this.selection == null)\n                            this.selection = line;\n                        else\n                            this.selection.add(line);\n\n                        // this.selection.add(line);\n                    }\n                }\n                //view.renderer.clear();\n                view.scene.add(this.selection);\n//                if (Session.get(\"virtual\") == true)\n//                    MarkersDetector.forceUpdate = true;\n////                else {\n//                    view.renderer.clear();\n//                    view.renderer.render(view.scene, view.camera);\n//                }\n            }\n        }\n    }\n    //Cut the bricks\n    if (markers.hasOwnProperty(40) && this.cutAvailable) {\n        Logger.postEvent(\"Cutting...\")\n        console.log(\"Cutting\");\n        this.cutAvailable = false;\n        var points = THREE.GeometryUtils.randomPointsInGeometry(this.mesh.geometry, 3);\n        points[0].applyMatrix4(this.mesh.matrix);\n        points[1].applyMatrix4(this.mesh.matrix);\n        points[2].applyMatrix4(this.mesh.matrix);\n        var plane = new THREE.Plane();\n        plane.setFromCoplanarPoints(points[0], points[1], points[2]);\n        var cutDone = false;\n        /*TODO: gestire caso del piano che contiene la retta\n         **/\n        for (var brickIndex in this.brickManager.bricks) {\n            var brick = this.brickManager.bricks[brickIndex];\n            if (brick.visibility) {\n                Logger.postEvent(\"Cutting-Brick:\" + brick.id);\n                brick.faces.updateMatrix();\n                var brickMatrix = brick.faces.matrix.clone();\n                if (this.checkFaceCut2(brick, plane, true)) {\n                    console.log(\"Invalid cut\");\n                    $(\"#anyError > #text\").text(\"Cutting a face\");\n                    $(\"#anyError\").show(200, function() {\n                        $(\"#anyError\").hide(5000);\n                    });\n                    continue;\n                }\n\n\n                view.removeBrickFromScene(brick);\n\n                /*In thise way we avoid to take into account the new blocks :)*/\n                for (var blockIndex = 0, numBlocks = brick.blocks.length; blockIndex < numBlocks; blockIndex++) {\n                    var block = brick.blocks[blockIndex];\n                    //console.log(\"Checking Block:\" + block.id)\n                    /*These arrays will contain the lines of the 2 new blocks */\n                    var geometries1 = new Array();\n                    var geometries2 = new Array();\n                    var intersectionPoints = new Array();\n                    /*These arrays contain the lines which are not involved in the cut.\n                     * Obviously, they need to be put in the right side*/\n                    var oldLines1 = new Array();\n                    var oldLines2 = new Array();\n                    /*Find intersection point*/\n                    for (var lineIndex = 0; lineIndex < block.lines.length; lineIndex++) {\n                        var line = block.lines[lineIndex];\n                        var line3 = new THREE.Line3(line.geometry.vertices[0].clone(), line.geometry.vertices[1].clone());\n                        line3.applyMatrix4(line.matrix);\n                        if (plane.isIntersectionLine(line3)\n                                ||\n                                plane.distanceToPoint(line3.start) == 0 ||\n                                plane.distanceToPoint(line3.end) == 0\n                                )\n                        {\n                            var point = plane.intersectLine(line3);\n                            if (point != undefined) {\n                                var inverseMatrix = line.matrix.clone();\n                                inverseMatrix = inverseMatrix.getInverse(inverseMatrix);\n                                var pointN = point.applyMatrix4(inverseMatrix);\n                                intersectionPoints.push([pointN, line]);\n                            }\n                        }\n                        /*If the line is not involved in the cut i keep it*/\n                        else {\n                            if (plane.distanceToPoint(line3.start) > 0) {\n                                var oldLine = line.clone();\n                                oldLine.name = \"\";\n                                oldLines1.push(oldLine);\n                            }\n                            else {\n                                var oldLine = line.clone();\n                                oldLine.name = \"\";\n                                oldLines2.push(oldLine);\n                            }\n                        }\n                    }\n                    //console.log(\"Intersections:\" + intersectionPoints.length);\n                    /*I've got the intersection points :) */\n                    if (intersectionPoints.length > 0) {\n                        if (this.checkFaceCut(block, intersectionPoints, plane)) {\n                            console.log(\"Invalid cutting\");\n                            Logger.postEvent(\"Cutting-a-Face-of-Block:\" + block.id);\n                            for (var i in intersectionPoints) {\n                                Logger.postEvent(\"Intersection-Point:(\" +\n                                        intersectionPoints[i][0].x + \",\" +\n                                        intersectionPoints[i][0].y + \",\" +\n                                        intersectionPoints[i][0].z + \");Local-Coordinates\");\n                            }\n                            $(\"#anyError > #text\").text(\"Cutting a face\");\n                            $(\"#anyError\").show(200, function() {\n                                $(\"#anyError\").hide(5000);\n                            })\n                            break;\n                        }\n                        if (this.checkDegenerateCut(intersectionPoints)) {\n                            console.log(\"Invalid cutting\");\n                            Logger.postEvent(\"Cutting-only-a-Point-of-Block:\" + block.id);\n                            for (var i in intersectionPoints) {\n                                Logger.postEvent(\"Intersection-Point:(\" +\n                                        intersectionPoints[i][0].x + \",\" +\n                                        intersectionPoints[i][0].y + \",\" +\n                                        intersectionPoints[i][0].z + \");Local-Coordinates\");\n                            }\n                            $(\"#anyError > #text\").text(\"Cutting on only one Point\");\n                            $(\"#anyError\").show(200, function() {\n                                $(\"#anyError\").hide(5000);\n                            });\n                            break;\n                        }\n                        if (cutDone == false) {\n                            cutDone = true;\n                            var backUp = [];\n                            backUp.push(brick.uniqueID.clone());\n                            for (var i in brick.blocks) {\n                                var bb = new Block(brick.blocks[i].id);\n                                bb.faces = brick.blocks[i].faces;\n                                bb.lines = brick.blocks[i].lines;\n                                backUp.push(bb);\n                            }\n                            brick.removedBlocks.push(backUp);\n                        }\n                        var newBlock = new Block(brick.uniqueID());\n                        var newId = newBlock.id;\n\n                        Logger.postEvent(\"Create-new-Block:\" + newBlock.id + \";from-Block:\" + block.id);\n                        for (var i in intersectionPoints) {\n                            Logger.postEvent(\"Intersection-Point:(\" +\n                                    intersectionPoints[i][0].x + \",\" +\n                                    intersectionPoints[i][0].y + \",\" +\n                                    intersectionPoints[i][0].z + \");Local-Coordinates\");\n                        }\n\n\n                        //$('#Shape' + brick.id + '>' + '#delete-shape').remove();\n                        $('#Shape' + brick.id + \"> #actions\").before(\"<button id=\\\"Block\" + newId + \"\\\" class=\\\"btn btn-mini\\\"  style=\\\"margin-top:5px;\\\">\" + newId + \"</button>\");\n                        $('#Shape' + brick.id + '>' + '#Block' + newId).css({'background-image': 'none', 'background-color': (this.colors[newId % this.colors.length])});\n\n                        (function(brick, newId, view) {\n                            $('#Shape' + brick.id + '>' + '#Block' + newId).on('click', $.proxy(function() {\n                                if (brick.visibility) {\n                                    $('#Shape' + brick.id + '>' + \"button[id*='Block']\").removeClass('btn-primary');\n                                    $('#Shape' + brick.id + '>' + \"button[id*='All']\").removeClass('btn-primary');\n                                    $('#Shape' + brick.id + '>' + '#Block' + newId).addClass('btn-primary');\n                                    //console.log(newId);\n                                    brick.highlightBlock();\n                                    //view.renderer.clear();\n//                                    if (Session.get(\"virtual\") == true)\n                                    MarkersDetector.forceUpdate = true;\n//                                    else\n//                                        view.renderer.render(view.scene, view.camera);\n                                }\n                            }, this));\n                        })(brick, newId, view);\n\n\n//                    $('#Shape' + brick.id).append(\"<button id=\\\"delete-shape\\\" class=\\\"btn btn-mini\\\">Delete</button>\");\n//                    $('#Shape' + brick.id + '> #delete-shape').on('click', function() {\n//                        view.removeBrickFromScene(brick);\n//                        brick.deleteBlock();\n//                        view.addBrickToScene(brick);\n//                        view.renderer.render(view.scene, view.camera);\n//\n//                    });\n\n                        brick.blocks.push(newBlock);\n\n                        var oldFaces = block.faces;\n\n                        /*For each face, the first array contains the points on the \n                         * \"right\" side; the other for the left side \n                         *  */\n                        var blockPoints = new Array(oldFaces.length);\n                        var newBlockPoints = new Array(oldFaces.length);\n\n                        block.lines = new Array();\n                        block.faces = new Array();\n\n                        for (var pointIndex = 0, length = intersectionPoints.length; pointIndex < length; pointIndex++) {\n                            var geometry1 = new THREE.Geometry();\n                            var geometry2 = new THREE.Geometry();\n                            var point = intersectionPoints[pointIndex][0];\n                            var startN = intersectionPoints[pointIndex][1].geometry.vertices[0].clone();\n                            var start = startN.clone().applyMatrix4(intersectionPoints[pointIndex][1].matrix);\n                            var endN = intersectionPoints[pointIndex][1].geometry.vertices[1].clone();\n                            var end = endN.clone().applyMatrix4(intersectionPoints[pointIndex][1].matrix);\n\n                            if (plane.distanceToPoint(start) == 0 && plane.distanceToPoint(end) == 0) {\n                                /*When the line is on the plane, the intersection point is the start.\n                                 * So we add the end as intersection point and \n                                 * computeNewLinesAndFaces will think about \n                                 * recreating the line*/\n                                if (point.distanceTo(start) < point.distanceTo(start))\n                                    intersectionPoints.push([endN.clone(), intersectionPoints[pointIndex][1].clone()]);\n                                else\n                                    intersectionPoints.push([startN.clone(), intersectionPoints[pointIndex][1].clone()]);\n\n                            }\n                            else if (plane.distanceToPoint(start) == 0) {\n                                if (plane.distanceToPoint(end) > 0) {\n                                    /*In this way we notify that start belongs\n                                     * to the block 1.*/\n                                    intersectionPoints[pointIndex].push(1);\n                                    geometry1.vertices.push(startN);\n                                    geometry1.vertices.push(endN);\n\n                                }\n                                else if (plane.distanceToPoint(end) < 0) {\n                                    intersectionPoints[pointIndex].push(-1);\n                                    geometry2.vertices.push(startN);\n                                    geometry2.vertices.push(endN);\n                                }\n\n                            }\n                            else if (plane.distanceToPoint(end) == 0) {\n                                if (plane.distanceToPoint(start) > 0) {\n                                    /*In this way we notify that start belongs\n                                     * to the block 1.*/\n                                    intersectionPoints[pointIndex].push(1);\n                                    geometry1.vertices.push(startN);\n                                    geometry1.vertices.push(endN);\n\n                                }\n                                else if (plane.distanceToPoint(start) < 0) {\n                                    intersectionPoints[pointIndex].push(-1);\n                                    geometry2.vertices.push(startN);\n                                    geometry2.vertices.push(endN);\n                                }\n                            }\n                            else if (plane.distanceToPoint(start) > 0) {\n                                /*In this way we notify that start belongs\n                                 * to the block 1.*/\n                                intersectionPoints[pointIndex].push(1);\n                                geometry1.vertices.push(startN);\n                                geometry1.vertices.push(point);\n                                geometry2.vertices.push(endN);\n                                geometry2.vertices.push(point);\n\n                            }\n                            else if (plane.distanceToPoint(start) < 0) {\n                                intersectionPoints[pointIndex].push(-1);\n                                geometry2.vertices.push(startN);\n                                geometry2.vertices.push(point);\n                                geometry1.vertices.push(endN);\n                                geometry1.vertices.push(point);\n                            }\n\n                            geometries1.push(geometry1);\n                            geometries2.push(geometry2);\n\n                        }\n\n                        for (var indexFace = 0; indexFace < oldFaces.length; indexFace++) {\n                            for (var indexPoint = 0; indexPoint < oldFaces[indexFace].length; indexPoint++) {\n                                var pointN = oldFaces[indexFace][indexPoint].clone();\n                                var point = pointN.clone().applyMatrix4(brickMatrix);\n\n                                if (blockPoints[indexFace] === undefined) {\n                                    blockPoints[indexFace] = new Array();\n                                    newBlockPoints[indexFace] = new Array();\n\n                                }\n                                if (plane.distanceToPoint(point) > 0) {\n                                    blockPoints[indexFace].push(pointN);\n                                }\n                                else if (plane.distanceToPoint(point) < 0) {\n                                    newBlockPoints[indexFace].push(pointN);\n                                }\n                                /*If the point is on the plane, it's an intersection\n                                 * point, the computeNewLinesAndFaces will\n                                 * deal with it*/\n                            }\n                        }\n\n                        /*At this point we have the lines of the two sides.*/\n                        for (var lineIndex = 0; lineIndex < geometries1.length; lineIndex++) {\n                            geometries1[lineIndex].computeLineDistances();\n                            var newline = new THREE.Line(geometries1[lineIndex], this.lineMaterial);\n                            block.lines.push(newline);\n                        }\n                        for (var lineIndex = 0; lineIndex < geometries2.length; lineIndex++) {\n                            geometries2[lineIndex].computeLineDistances();\n                            var newline = new THREE.Line(geometries2[lineIndex], this.lineMaterial);\n                            newBlock.lines.push(newline);\n                        }\n\n                        var newElements = this.computeNewLinesAndFaces(oldFaces, intersectionPoints, oldLines1, blockPoints, newBlockPoints);\n                        var newLines = newElements[0];\n                        block.faces = newElements[1];\n                        newBlock.faces = newElements[2];\n                        block.lines = block.lines.concat(oldLines1, newLines);\n                        var newLines2 = new Array();\n                        for (var g in newLines) {\n                            newLines2.push(newLines[g].clone());\n                        }\n                        newBlock.lines = newBlock.lines.concat(oldLines2, newLines2);\n\n                    }\n                }\n\n                //brick.removedBlocks = new Array();\n                //$('#Shape' + brick.id + '> #restore-shape').text(\"Undo(0)\");\n                brick.recreateBrick();\n                view.addBrickToScene(brick);\n//                if (Session.get(\"virtual\") == true)\n//                    MarkersDetector.forceUpdate = true;\n//                else\n//                    view.renderer.render(view.scene, view.camera);\n            }\n        }\n        console.log(\"Cuttind end\")\n    }\n\n}\n\n/*Check if a face is on the cutting plane*/\nPlaneCutter.prototype.checkFaceCut = function(block, intersectionPoints, plane) {\n    if (intersectionPoints.length <= 2)\n        return true;\n    //console.log(\"Checking face for block:\" + block.id);\n    var newInterPoint = [];\n\n    for (var index = 0, indexMax = intersectionPoints.length; index < indexMax; index++) {\n        /*Adding intersection points when the line is coplanar*/\n        var line = intersectionPoints[index][1];\n        var line3 = new THREE.Line3(line.geometry.vertices[0].clone(), line.geometry.vertices[1].clone());\n        line3.applyMatrix4(line.matrix);\n        newInterPoint.push(intersectionPoints[index]);\n        if (plane.distanceToPoint(line3.start) == 0 && plane.distanceToPoint(line3.end) == 0) {\n            newInterPoint.push([line.geometry.vertices[1].clone(), line.clone()]);\n        }\n    }\n\n    intersectionPoints = newInterPoint;\n    for (var indexFace = 0; indexFace < block.faces.length; indexFace++) {\n        var face = block.faces[indexFace];\n        var flag = 0;\n        for (var indexPoint = 0; indexPoint < face.length; indexPoint++) {\n            var minD = 1000;\n            for (var indexIntersect = 0; indexIntersect < intersectionPoints.length; indexIntersect++) {\n                var facePoint = face[indexPoint].clone();\n                var cutPoint = intersectionPoints[indexIntersect][0].clone();\n                var distance = facePoint.distanceTo(cutPoint);\n                if (distance < minD)\n                    minD = distance;\n\n            }\n            if (minD < 0.5)\n                flag++;\n        }\n        if (flag > 2)\n            return true;\n\n    }\n    return false;\n}\nPlaneCutter.prototype.checkFaceCut2 = function(brick, plane, postFlag) {\n\n    for (var indexBlock = 0; indexBlock < brick.blocks.length; indexBlock++) {\n        var block = brick.blocks[indexBlock];\n        for (var indexFace = 0; indexFace < block.faces.length; indexFace++) {\n            var flag = 0;\n            for (var indexPoint = 0; indexPoint < block.faces[indexFace].length; indexPoint++) {\n                var point = block.faces[indexFace][indexPoint].clone();\n                point = point.applyMatrix4(brick.faces.matrix);\n                if (Math.abs(plane.distanceToPoint(point)) < 0.5) {\n                    flag++;\n                }\n            }\n            if (flag > 2) {\n                if (postFlag)\n                    Logger.postEvent(\"Cutting-a-Face;Brick:\" + brick.id + \";Block:\" + block.id + \";Face:\" + indexFace);\n                return true;\n            }\n        }\n    }\n    return false;\n\n}\n\nPlaneCutter.prototype.computeNewLinesAndFaces = function(oldFaces, intersectionPoints, OldLines1, blockPoints, newBlockPoints) {\n    /*Create new lines between intersection points and new faces*/\n    var newLines = new Array();\n    var newFaces1 = new Array();\n    var newFaces2 = new Array();\n\n    /*Initial creation of the faces. This puts the points of the old block\n     * in the correct new block*/\n    for (var faceIndex = 0; faceIndex < oldFaces.length; faceIndex++) {\n        newFaces1.push(blockPoints[faceIndex]);\n        newFaces2.push(newBlockPoints[faceIndex]);\n    }\n\n    for (var pointIndex1 = 0; pointIndex1 < intersectionPoints.length; pointIndex1++) {\n        var start = intersectionPoints[pointIndex1][1].geometry.vertices[0].clone();\n        var end = intersectionPoints[pointIndex1][1].geometry.vertices[1].clone();\n        for (var faceIndex = 0; faceIndex < oldFaces.length; faceIndex++) {\n            var checkFlag = 0;\n            /*Find the face which contains the line*/\n            for (var planePointIndex = 0; planePointIndex < oldFaces[faceIndex].length; planePointIndex++) {\n                if (oldFaces[faceIndex][planePointIndex].equals(start) || oldFaces[faceIndex][planePointIndex].equals(end)) {\n                    checkFlag++;\n                }\n            }\n            if (checkFlag == 2) {\n                /*Add the intersection point to the faces of the new blocks*/\n                newFaces1[faceIndex].push(intersectionPoints[pointIndex1][0].clone());\n                newFaces2[faceIndex].push(intersectionPoints[pointIndex1][0].clone());\n\n                /*Look for another intersaction point on the same face to create\n                 * a new line*/\n                for (var pointIndex2 = pointIndex1 + 1; pointIndex2 < intersectionPoints.length; pointIndex2++) {\n                    var start2 = intersectionPoints[pointIndex2][1].geometry.vertices[0].clone();\n                    var end2 = intersectionPoints[pointIndex2][1].geometry.vertices[1].clone();\n                    var checkFlag2 = 0;\n\n                    for (var planePointIndex = 0; planePointIndex < oldFaces[faceIndex].length; planePointIndex++) {\n                        if (oldFaces[faceIndex][planePointIndex].equals(start2) || oldFaces[faceIndex][planePointIndex].equals(end2)) {\n                            checkFlag2++;\n                        }\n                    }\n                    if (checkFlag2 == 2) {\n                        //Add lines\n                        var geometry = new THREE.Geometry();\n                        geometry.vertices.push(intersectionPoints[pointIndex1][0].clone());\n                        geometry.vertices.push(intersectionPoints[pointIndex2][0].clone());\n                        var line = new THREE.Line(geometry, this.lineMaterial);\n                        newLines.push(line);\n                    }\n                }\n\n            }\n\n        }\n    }\n\n    /*Basically add the new faces made of the intersection points*/\n    var lastFace = new Array();\n    var lastFace2 = new Array();\n    for (var pointIndex1 = 0; pointIndex1 < intersectionPoints.length; pointIndex1++) {\n        lastFace.push(intersectionPoints[pointIndex1][0].clone());\n        lastFace2.push(intersectionPoints[pointIndex1][0].clone());\n    }\n    newFaces1.push(lastFace);\n    newFaces2.push(lastFace2);\n\n    /*Delete empty faces*/\n    for (var i = newFaces1.length - 1; i >= 0; i--) {\n        if (newFaces1[i].length == 0) {\n            newFaces1.splice(i, 1);\n        }\n    }\n    for (var i = newFaces2.length - 1; i >= 0; i--) {\n        if (newFaces2[i].length == 0) {\n            newFaces2.splice(i, 1);\n        }\n    }\n\n    /*Sort the vertices in the faces*/\n    for (var indexFace = 0; indexFace < newFaces1.length; indexFace++) {\n        var face = newFaces1[indexFace];\n        newFaces1[indexFace] = this.sortVertices(face);\n    }\n    for (var indexFace = 0; indexFace < newFaces2.length; indexFace++) {\n        var face = newFaces2[indexFace];\n        newFaces2[indexFace] = this.sortVertices(face);\n    }\n    return [newLines, newFaces1, newFaces2];\n\n}\n\nPlaneCutter.prototype.sortVertices = function(face) {\n    //console.log(\"Sorting Vertices:\", face);\n    /*Delete duplicates*/\n    var clean_face = new Array();\n    for (var indexPoint1 = 0; indexPoint1 < face.length; indexPoint1++) {\n        var unique = true;\n        for (var indexPoint2 = indexPoint1 + 1; indexPoint2 < face.length; indexPoint2++) {\n            if (face[indexPoint1].equals(face[indexPoint2])) {\n                unique = false;\n                break;\n            }\n        }\n        if (unique)\n            clean_face.push(face[indexPoint1]);\n    }\n    //console.log(\"Aftern Cleaning:\", clean_face);\n\n    //face =clean_face;\n\n\n    var plane = new THREE.Plane();\n    //inultile\n\n    plane.setFromCoplanarPoints(clean_face[0], clean_face[1], clean_face[2]);\n\n    //centroid\n    var centroid = new THREE.Vector3(clean_face[0].x, clean_face[0].y, clean_face[0].z);\n    for (var indexPoint = 1; indexPoint < clean_face.length; indexPoint++) {\n        centroid = centroid.add(clean_face[indexPoint]);\n    }\n    centroid = centroid.divideScalar(clean_face.length);\n    // console.log(\"Centroid:\", centroid);\n\n    var angles = new Array();\n\n    var z_axis = plane.normal;\n    z_axis = z_axis.normalize();\n    if (z_axis.equals(new THREE.Vector3(0, 0, 0))) {\n        console.log(\"er\");\n//        console.log(clean_face[0]);\n//        console.log(clean_face[1]);\n//        console.log(clean_face[2]);\n    }\n    var x_axis, y_axis;\n    if (z_axis.equals(new THREE.Vector3(0, 0, 1)) || z_axis.equals(new THREE.Vector3(0, 0, -1))) {\n        x_axis = new THREE.Vector3(1, 0, 0);\n        y_axis = new THREE.Vector3(0, 1, 0);\n    }\n    else {\n        x_axis = z_axis.clone().cross(new THREE.Vector3(0, 0, 1));\n        y_axis = x_axis.clone().cross(z_axis);\n    }\n    x_axis = x_axis.normalize();\n    y_axis = y_axis.normalize();\n    // console.log(\"Axis:\", x_axis, y_axis, z_axis);\n\n    var newIndexOrder = new Array();\n    for (var indexPoint = 0; indexPoint < clean_face.length; indexPoint++) {\n        newIndexOrder.push(indexPoint);\n        var point = clean_face[indexPoint].clone();\n        point = point.sub(centroid);\n        angles[indexPoint] = Math.atan2(point.dot(y_axis), point.dot(x_axis));\n    }\n\n    var newFace = new Array(clean_face.length);\n    newIndexOrder.sort(function(a, b) {\n        return angles[a] - angles[b]\n    });\n\n\n\n\n\n    for (var i = 0; i < newIndexOrder.length; i++) {\n        newFace[i] = clean_face[newIndexOrder[i]];\n    }\n    return newFace;\n}\n\nPlaneCutter.prototype.intersectionPlaneLine = function(plane, line) {\n\n    var startSign = plane.distanceToPoint(line.start);\n    var endSign = plane.distanceToPoint(line.end);\n\n    if (Math.abs(startSign) < 0.5)\n        startSign = 0;\n    if (Math.abs(endSign) < 0.5)\n        endSign = 0;\n\n    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);\n}\n\nPlaneCutter.prototype.checkDegenerateCut = function(intersectionPoints) {\n    if (intersectionPoints.length == 1)\n        return true;\n\n    return false;\n}\n\n\n ","ToolManager = function(){\n\tthis.tools = {};\n}\n\nToolManager.prototype.addTool = function(tool){\n    this.tools[tool.id] = tool;\n};\n\n/*BrickManager.getRotationAndPositionOfBrick = function(marker) {\n    var Z = Session.get('shapes')[marker.id].markerZ;\n    var marker_position = [marker.corners[0].x, marker.corners[0].y, 1];\n    var marker_position2 = [marker.corners[1].x, marker.corners[1].y, 1];\n    var position = pixel2mm(marker_position[0], marker_position[1], Z);\n    var position2 = pixel2mm(marker_position2[0], marker_position2[1], Z);\n    var rotation;\n    var diffx = position.x-position2.x;\n    var diffy = position.y-position2.y;\n    if (diffy == 0){  diffy = 1;    }\n    if ((diffx < 0 && diffy > 0) || (diffx > 0 && diffy > 0)) {\n        rotation = -Math.atan(diffx/diffy)+Math.PI/2;\n    }\n    else{\n        rotation = -Math.atan(diffx/diffy)-Math.PI/2;\n    }\n\treturn {r : rotation, p: position};\n}*/\n\n"]}